{"ast":null,"code":"import _extends from '@babel/runtime/helpers/extends';\nimport _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport _objectWithoutProperties from '@babel/runtime/helpers/objectWithoutProperties';\nimport _regeneratorRuntime from '@babel/runtime/regenerator';\nimport _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';\nimport _classCallCheck from '@babel/runtime/helpers/classCallCheck';\nimport _createClass from '@babel/runtime/helpers/createClass';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _typeof from '@babel/runtime/helpers/typeof';\nimport axios from 'axios';\nimport uuidv4 from 'uuid/v4';\nimport Immutable from 'seamless-immutable';\nimport isoWS from 'isomorphic-ws';\nimport fetch, { Headers } from 'cross-fetch';\nimport FormData from 'form-data';\n/**\n * ChannelState - A container class for the channel state.\n */\n\nfunction byDate(a, b) {\n  return a.created_at - b.created_at;\n}\n\nvar ChannelState = /*#__PURE__*/function () {\n  function ChannelState(channel) {\n    _classCallCheck(this, ChannelState);\n\n    this._channel = channel;\n    this.watcher_count = 0;\n    this.typing = Immutable({});\n    this.read = Immutable({});\n    this.messages = Immutable([]);\n    this.threads = Immutable({}); // a list of users to hide messages from\n\n    this.mutedUsers = Immutable([]);\n    this.watchers = Immutable({});\n    this.members = Immutable({});\n    this.last_message_at = channel.last_message_at != null ? new Date(channel.last_message_at) : null;\n  }\n  /**\n   * addMessageSorted - Add a message to the state\n   *\n   * @param {object} newMessage A new message\n   *\n   */\n\n\n  _createClass(ChannelState, [{\n    key: \"addMessageSorted\",\n    value: function addMessageSorted(newMessage) {\n      return this.addMessagesSorted([newMessage]);\n    }\n    /**\n     * messageToImmutable - Takes the message object. Parses the dates, sets __html\n     * and sets the status to received if missing. Returns an immutable message object\n     *\n     * @param {object} message an Immutable message object\n     *\n     */\n\n  }, {\n    key: \"messageToImmutable\",\n    value: function messageToImmutable(message) {\n      message.__html = message.html; // parse the date..\n\n      message.created_at = new Date(message.created_at);\n      message.updated_at = new Date(message.updated_at);\n\n      if (!message.status) {\n        message.status = 'received';\n      }\n\n      return Immutable(message);\n    }\n    /**\n     * addMessagesSorted - Add the list of messages to state and resorts the messages\n     *\n     * @param {array}   newMessages    A list of messages\n     * @param {boolean} initializing   Weather channel is being initialized.\n     *\n     */\n\n  }, {\n    key: \"addMessagesSorted\",\n    value: function addMessagesSorted(newMessages) {\n      var initializing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // parse all the new message dates and add __html for react\n\n      var parsedMessages = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = newMessages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var message = _step.value;\n\n          if (initializing && this.threads[message.id]) {\n            // If we are initializing the state of channel (e.g., in case of connection recovery),\n            // then in that case we remove thread related to this message from threads object.\n            // This way we can ensure that we don't have any stale data in thread object\n            // and consumer can refetch the replies.\n            this.threads = Immutable.without(this.threads, message.id);\n          }\n\n          var parsedMsg = this.messageToImmutable(message);\n          parsedMessages.push(parsedMsg);\n\n          if (parsedMsg.created_at > this.last_message_at) {\n            this.last_message_at = parsedMsg.created_at;\n          }\n        } // update or append the messages...\n\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var updatedThreads = [];\n\n      for (var _i = 0, _parsedMessages = parsedMessages; _i < _parsedMessages.length; _i++) {\n        var _message = _parsedMessages[_i];\n        var isThreadReply = _message.parent_id && !_message.show_in_channel; // add to the main message list\n\n        if (!isThreadReply) {\n          this.messages = this._addToMessageList(this.messages, _message);\n        } // add to the thread if applicable..\n\n\n        var parentID = _message.parent_id;\n\n        if (parentID) {\n          var thread = this.threads[parentID] || Immutable([]);\n\n          var threadMessages = this._addToMessageList(thread, _message);\n\n          this.threads = this.threads.set(parentID, threadMessages);\n          updatedThreads.push(parentID);\n        }\n      } // Resort the main messages and the threads that changed...\n\n\n      var messages = _toConsumableArray(this.messages);\n\n      messages.sort(byDate);\n      this.messages = Immutable(messages);\n\n      for (var _i2 = 0, _updatedThreads = updatedThreads; _i2 < _updatedThreads.length; _i2++) {\n        var _parentID = _updatedThreads[_i2];\n\n        var _threadMessages = this.threads[_parentID] ? _toConsumableArray(this.threads[_parentID]) : [];\n\n        _threadMessages.sort(byDate);\n\n        this.threads = this.threads.set(_parentID, _threadMessages);\n      }\n    }\n  }, {\n    key: \"addReaction\",\n    value: function addReaction(reaction, message) {\n      var messages = this.messages;\n      if (!message) return;\n      var parent_id = message.parent_id,\n          show_in_channel = message.show_in_channel;\n\n      if (parent_id && this.threads[parent_id]) {\n        var thread = this.threads[parent_id];\n\n        for (var i = 0; i < thread.length; i++) {\n          var _message2 = thread[i];\n          _message2 = this._addReactionToMessage(_message2, reaction);\n\n          if (!_message2) {\n            continue;\n          }\n\n          this.threads = this.threads.set(parent_id, thread.set(i, _message2));\n          break;\n        }\n      }\n\n      if (!show_in_channel && !parent_id || show_in_channel) {\n        for (var _i3 = 0; _i3 < messages.length; _i3++) {\n          var _message3 = messages[_i3];\n          _message3 = this._addReactionToMessage(_message3, reaction);\n\n          if (!_message3) {\n            continue;\n          }\n\n          this.messages = messages.set(_i3, _message3);\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"_addReactionToMessage\",\n    value: function _addReactionToMessage(message, reaction) {\n      var idMatch = message.id && message.id === reaction.message_id;\n\n      if (!idMatch) {\n        return false;\n      }\n\n      message = this._removeReactionFromMessage(message, reaction);\n\n      if (this._channel.getClient().userID === reaction.user.id) {\n        message = message.update('own_reactions', function () {\n          var old = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n          return old.concat([reaction]);\n        });\n      }\n\n      message = message.update('latest_reactions', function () {\n        var old = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        return old.concat([reaction]);\n      });\n      message = message.updateIn(['reaction_counts', reaction.type], function (old) {\n        return old ? old + 1 : 1;\n      });\n      return message;\n    }\n  }, {\n    key: \"_removeReactionFromMessage\",\n    value: function _removeReactionFromMessage(message, reaction) {\n      var filterReaction = function filterReaction(old) {\n        return old.filter(function (item) {\n          return item.type !== reaction.type || item.user.id !== reaction.user.id;\n        });\n      };\n\n      message = message.update('own_reactions', filterReaction);\n      message = message.update('latest_reactions', filterReaction);\n      return message;\n    }\n  }, {\n    key: \"removeReaction\",\n    value: function removeReaction(reaction, message) {\n      var messages = this.messages;\n      if (!message) return;\n      var parent_id = message.parent_id,\n          show_in_channel = message.show_in_channel;\n\n      if (parent_id && this.threads[parent_id]) {\n        var thread = this.threads[parent_id];\n\n        for (var i = 0; i < thread.length; i++) {\n          var _message4 = thread[i];\n          var idMatch = _message4.id && _message4.id === reaction.message_id;\n\n          if (!idMatch) {\n            continue;\n          }\n\n          _message4 = this._removeReactionFromMessage(_message4, reaction);\n          _message4 = _message4.updateIn(['reaction_counts', reaction.type], function (old) {\n            return old ? old - 1 : 0;\n          });\n          this.threads = this.threads.set(parent_id, thread.set(i, _message4));\n          break;\n        }\n      }\n\n      if (!show_in_channel && !parent_id || show_in_channel) {\n        for (var _i4 = 0; _i4 < messages.length; _i4++) {\n          var _message5 = messages[_i4];\n\n          var _idMatch = _message5.id && _message5.id === reaction.message_id;\n\n          if (!_idMatch) {\n            continue;\n          }\n\n          _message5 = this._removeReactionFromMessage(_message5, reaction);\n          _message5 = _message5.updateIn(['reaction_counts', reaction.type], function (old) {\n            return old ? old - 1 : 0;\n          });\n          this.messages = messages.set(_i4, _message5);\n          break;\n        }\n      }\n    }\n    /**\n     * _addToMessageList - Adds a message to a list of messages, tries to update first, appends if message isnt found\n     *\n     * @param {array} messages A list of messages\n     * @param {object} newMessage The new message\n     *\n     */\n\n  }, {\n    key: \"_addToMessageList\",\n    value: function _addToMessageList(messages, newMessage) {\n      var updated = false;\n\n      for (var i = 0; i < messages.length; i++) {\n        var message = messages[i];\n        var idMatch = message.id && newMessage.id && message.id === newMessage.id;\n\n        if (idMatch) {\n          messages = messages.set(i, newMessage);\n          updated = true;\n        }\n      }\n\n      if (!updated) {\n        messages = messages.concat([newMessage]);\n      }\n\n      return messages;\n    }\n    /**\n     * removeMessage - Description\n     *\n     * @param {type} messageToRemove Object of the message to remove. Needs to have at id specified.\n     *\n     * @return {boolean} Returns if the message was removed\n     */\n\n  }, {\n    key: \"removeMessage\",\n    value: function removeMessage(messageToRemove) {\n      var removed = false;\n      var messages = this.messages.flatMap(function (message) {\n        var idMatch = message.id && messageToRemove.id && message.id === messageToRemove.id;\n\n        if (idMatch) {\n          return [];\n        } else {\n          removed = true;\n          return message;\n        }\n      });\n      this.messages = messages;\n      return removed;\n    }\n    /**\n     * filterErrorMessages - Removes error messages from the channel state.\n     *\n     */\n\n  }, {\n    key: \"filterErrorMessages\",\n    value: function filterErrorMessages() {\n      var filteredMessages = this.messages.flatMap(function (message) {\n        if (message.type !== 'error') {\n          return message;\n        } else {\n          return [];\n        }\n      });\n      this.messages = Immutable(filteredMessages);\n    }\n    /**\n     * clean - Remove stale data such as users that stayed in typing state for more than 5 seconds\n     */\n\n  }, {\n    key: \"clean\",\n    value: function clean() {\n      var now = new Date(); // prevent old users from showing up as typing\n\n      for (var _i5 = 0, _Object$entries = Object.entries(this.typing); _i5 < _Object$entries.length; _i5++) {\n        var _Object$entries$_i = _slicedToArray(_Object$entries[_i5], 2),\n            userID = _Object$entries$_i[0],\n            lastEvent = _Object$entries$_i[1];\n\n        var since = now - new Date(lastEvent.received_at);\n\n        if (since > 7000) {\n          this.typing = this.typing.without(userID);\n\n          this._channel.getClient().dispatchEvent({\n            type: 'typing.stop',\n            user: {\n              id: userID\n            },\n            cid: this._channel.cid\n          });\n        }\n      }\n    }\n  }]);\n\n  return ChannelState;\n}();\n\nvar EVENT_MAP = {\n  'user.presence.changed': true,\n  'user.watching.start': true,\n  'user.watching.stop': true,\n  'user.updated': true,\n  'typing.start': true,\n  'typing.stop': true,\n  'message.new': true,\n  'message.updated': true,\n  'message.deleted': true,\n  'message.read': true,\n  'reaction.new': true,\n  'reaction.deleted': true,\n  'member.added': true,\n  'member.updated': true,\n  'member.removed': true,\n  'channel.updated': true,\n  'channel.deleted': true,\n  'health.check': true,\n  'notification.message_new': true,\n  'notification.mark_read': true,\n  'notification.invited': true,\n  'notification.invite_accepted': true,\n  'notification.added_to_channel': true,\n  'notification.removed_from_channel': true,\n  'notification.mutes_updated': true,\n  // local events\n  'connection.changed': true,\n  'connection.recovered': true\n};\n\nfunction isValidEventType(eventType) {\n  if (eventType === 'all') {\n    return true;\n  }\n\n  return EVENT_MAP[eventType] || false;\n}\n/**\n * logChatPromiseExecution - utility function for logging the execution of a promise..\n *  use this when you want to run the promise and handle errors by logging a warning\n *\n * @param {type} promise The promise you want to run and log\n * @param {type} name    A descriptive name of what the promise does for log output\n *\n */\n\n\nfunction logChatPromiseExecution(promise, name) {\n  promise.then(function () {// do nothing...\n  }).catch(function (error) {\n    console.warn(\"failed to do \".concat(name, \", ran into error: \"), error);\n  });\n}\n\nvar sleep = function sleep(m) {\n  return new Promise(function (r) {\n    return setTimeout(r, m);\n  });\n};\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n/**\n * Channel - The Channel class manages it's own state.\n */\n\n\nvar Channel = /*#__PURE__*/function () {\n  /**\n   * constructor - Create a channel\n   *\n   * @param {Client} client the chat client\n   * @param {string} type  the type of channel\n   * @param {string} [id]  the id of the chat\n   * @param {type} custom any additional custom params\n   *\n   * @return {Channel} Returns a new uninitialized channel\n   */\n  function Channel(client, type, id, data) {\n    var _this = this;\n\n    _classCallCheck(this, Channel);\n\n    _defineProperty(this, \"create\", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var options;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              options = {\n                watch: false,\n                state: false,\n                presence: false\n              };\n              _context.next = 3;\n              return _this.query(options);\n\n            case 3:\n              return _context.abrupt(\"return\", _context.sent);\n\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    })));\n\n    _defineProperty(this, \"_channelURL\", function () {\n      if (!_this.id) {\n        throw new Error('channel id is not defined');\n      }\n\n      var channelURL = \"\".concat(_this.getClient().baseURL, \"/channels/\").concat(_this.type, \"/\").concat(_this.id);\n      return channelURL;\n    });\n\n    var validTypeRe = /^[\\w_-]+$/;\n    var validIDRe = /^[\\w!_-]+$/;\n\n    if (!validTypeRe.test(type)) {\n      throw new Error(\"Invalid chat type \".concat(type, \", letters, numbers and \\\"_-\\\" are allowed\"));\n    }\n\n    if (!validIDRe.test(id)) {\n      throw new Error(\"Invalid chat id \".concat(id, \", letters, numbers and \\\"!-_\\\" are allowed\"));\n    }\n\n    this._client = client;\n    this.type = type;\n    this.id = id; // used by the frontend, gets updated:\n\n    this.data = data; // this._data is used for the requests...\n\n    this._data = _objectSpread({}, data);\n    this.cid = \"\".concat(type, \":\").concat(id);\n    this.listeners = {}; // perhaps the state variable should be private\n\n    this.state = new ChannelState(this);\n    this.initialized = false;\n    this.lastTypingEvent = null;\n    this.isTyping = false;\n    this.disconnected = false;\n  }\n  /**\n   * getClient - Get the chat client for this channel. If client.disconnect() was called, this function will error\n   *\n   * @return {object}\n   */\n\n\n  _createClass(Channel, [{\n    key: \"getClient\",\n    value: function getClient() {\n      if (this.disconnected === true) {\n        throw Error(\"You can't use a channel after client.disconnect() was called\");\n      }\n\n      return this._client;\n    }\n    /**\n     * getConfig - Get the configs for this channel type\n     *\n     * @return {object}\n     */\n\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      var client = this.getClient();\n      return client.configs[this.type];\n    }\n    /**\n     * sendMessage - Send a message to this channel\n     *\n     * @param {object} message The Message object\n     *\n     * @return {object} The Server Response\n     */\n\n  }, {\n    key: \"sendMessage\",\n    value: function () {\n      var _sendMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(message) {\n        var data;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.getClient().post(this._channelURL() + '/message', {\n                  message: message\n                });\n\n              case 2:\n                data = _context2.sent;\n                return _context2.abrupt(\"return\", data);\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function sendMessage(_x) {\n        return _sendMessage.apply(this, arguments);\n      }\n\n      return sendMessage;\n    }()\n  }, {\n    key: \"sendFile\",\n    value: function sendFile(uri, name, contentType, user) {\n      return this.getClient().sendFile(\"\".concat(this._channelURL(), \"/file\"), uri, name, contentType, user);\n    }\n  }, {\n    key: \"sendImage\",\n    value: function sendImage(uri, name, contentType, user) {\n      return this.getClient().sendFile(\"\".concat(this._channelURL(), \"/image\"), uri, name, contentType, user);\n    }\n  }, {\n    key: \"deleteFile\",\n    value: function deleteFile(url) {\n      return this.getClient().delete(\"\".concat(this._channelURL(), \"/file\"), {\n        url: url\n      });\n    }\n  }, {\n    key: \"deleteImage\",\n    value: function deleteImage(url) {\n      return this.getClient().delete(\"\".concat(this._channelURL(), \"/image\"), {\n        url: url\n      });\n    }\n    /**\n     * sendEvent - Send an event on this channel\n     *\n     * @param {object} event for example {type: 'message.read'}\n     *\n     * @return {object} The Server Response\n     */\n\n  }, {\n    key: \"sendEvent\",\n    value: function () {\n      var _sendEvent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(event) {\n        var data;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this._checkInitialized();\n\n                _context3.next = 3;\n                return this.getClient().post(this._channelURL() + '/event', {\n                  event: event\n                });\n\n              case 3:\n                data = _context3.sent;\n                return _context3.abrupt(\"return\", data);\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function sendEvent(_x2) {\n        return _sendEvent.apply(this, arguments);\n      }\n\n      return sendEvent;\n    }()\n    /**\n     * sendReaction - Send a reaction about a message\n     *\n     * @param {string} messageID the message id\n     * @param {object} reaction the reaction object for instance {type: 'love'}\n     * @param {string} user_id the id of the user (used only for server side request) default null\n     *\n     * @return {object} The Server Response\n     */\n\n  }, {\n    key: \"sendReaction\",\n    value: function () {\n      var _sendReaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(messageID, reaction, user_id) {\n        var body, data;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (messageID) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                throw Error(\"Message id is missing\");\n\n              case 2:\n                if (!(!reaction || Object.keys(reaction).length === 0)) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                throw Error(\"Reaction object is missing\");\n\n              case 4:\n                body = {\n                  reaction: reaction\n                };\n\n                if (user_id != null) {\n                  body.reaction = _objectSpread({}, reaction, {\n                    user: {\n                      id: user_id\n                    }\n                  });\n                }\n\n                _context4.next = 8;\n                return this.getClient().post(this.getClient().baseURL + \"/messages/\".concat(messageID, \"/reaction\"), body);\n\n              case 8:\n                data = _context4.sent;\n                return _context4.abrupt(\"return\", data);\n\n              case 10:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function sendReaction(_x3, _x4, _x5) {\n        return _sendReaction.apply(this, arguments);\n      }\n\n      return sendReaction;\n    }()\n    /**\n     * deleteReaction - Delete a reaction by user and type\n     *\n     * @param {string} messageID the id of the message from which te remove the reaction\n     * @param {string} reactionType the type of reaction that should be removed\n     * @param {string} user_id the id of the user (used only for server side request) default null\n     *\n     * @return {object} The Server Response\n     */\n\n  }, {\n    key: \"deleteReaction\",\n    value: function deleteReaction(messageID, reactionType, user_id) {\n      this._checkInitialized();\n\n      if (!reactionType || !messageID) {\n        throw Error('Deleting a reaction requires specifying both the message and reaction type');\n      }\n\n      var url = this.getClient().baseURL + \"/messages/\".concat(messageID, \"/reaction/\").concat(reactionType); //provided when server side request\n\n      if (user_id) {\n        return this.getClient().delete(url, {\n          user_id: user_id\n        });\n      }\n\n      return this.getClient().delete(url);\n    }\n    /**\n     * update - Edit the channel's custom properties\n     *\n     * @param {object} custom The object to update the custom properties of this channel with\n     *\n     * @return {type} The server response\n     */\n\n  }, {\n    key: \"update\",\n    value: function () {\n      var _update = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(channelData, updateMessage) {\n        var data;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.getClient().post(this._channelURL(), {\n                  message: updateMessage,\n                  data: channelData\n                });\n\n              case 2:\n                data = _context5.sent;\n                this.data = data.channel;\n                return _context5.abrupt(\"return\", data);\n\n              case 5:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function update(_x6, _x7) {\n        return _update.apply(this, arguments);\n      }\n\n      return update;\n    }()\n    /**\n     * delete - Delete the channel.. Messages are permanently removed.\n     *\n     * @return {object} The server response\n     */\n\n  }, {\n    key: \"delete\",\n    value: function () {\n      var _delete2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var data;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.getClient().delete(this._channelURL());\n\n              case 2:\n                data = _context6.sent;\n                return _context6.abrupt(\"return\", data);\n\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _delete() {\n        return _delete2.apply(this, arguments);\n      }\n\n      return _delete;\n    }()\n    /**\n     * truncate - Removes all messages from the channel\n     *\n     * @return {object} The server response\n     */\n\n  }, {\n    key: \"truncate\",\n    value: function () {\n      var _truncate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var data;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this.getClient().post(this._channelURL() + '/truncate');\n\n              case 2:\n                data = _context7.sent;\n                return _context7.abrupt(\"return\", data);\n\n              case 4:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function truncate() {\n        return _truncate.apply(this, arguments);\n      }\n\n      return truncate;\n    }()\n  }, {\n    key: \"acceptInvite\",\n    value: function () {\n      var _acceptInvite = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        var options,\n            data,\n            _args8 = arguments;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                options = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {};\n                _context8.next = 3;\n                return this.getClient().post(this._channelURL(), _objectSpread({\n                  accept_invite: true\n                }, options));\n\n              case 3:\n                data = _context8.sent;\n                this.data = data.channel;\n                return _context8.abrupt(\"return\", data);\n\n              case 6:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function acceptInvite() {\n        return _acceptInvite.apply(this, arguments);\n      }\n\n      return acceptInvite;\n    }()\n  }, {\n    key: \"rejectInvite\",\n    value: function () {\n      var _rejectInvite = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var options,\n            data,\n            _args9 = arguments;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                options = _args9.length > 0 && _args9[0] !== undefined ? _args9[0] : {};\n                _context9.next = 3;\n                return this.getClient().post(this._channelURL(), _objectSpread({\n                  reject_invite: true\n                }, options));\n\n              case 3:\n                data = _context9.sent;\n                this.data = data.channel;\n                return _context9.abrupt(\"return\", data);\n\n              case 6:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function rejectInvite() {\n        return _rejectInvite.apply(this, arguments);\n      }\n\n      return rejectInvite;\n    }()\n  }, {\n    key: \"addMembers\",\n    value: function () {\n      var _addMembers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(members) {\n        var data;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return this.getClient().post(this._channelURL(), {\n                  add_members: members\n                });\n\n              case 2:\n                data = _context10.sent;\n                this.data = data.channel;\n                return _context10.abrupt(\"return\", data);\n\n              case 5:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function addMembers(_x8) {\n        return _addMembers.apply(this, arguments);\n      }\n\n      return addMembers;\n    }()\n  }, {\n    key: \"addModerators\",\n    value: function () {\n      var _addModerators = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(members) {\n        var data;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.next = 2;\n                return this.getClient().post(this._channelURL(), {\n                  add_moderators: members\n                });\n\n              case 2:\n                data = _context11.sent;\n                this.data = data.channel;\n                return _context11.abrupt(\"return\", data);\n\n              case 5:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function addModerators(_x9) {\n        return _addModerators.apply(this, arguments);\n      }\n\n      return addModerators;\n    }()\n  }, {\n    key: \"removeMembers\",\n    value: function () {\n      var _removeMembers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(members) {\n        var data;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.next = 2;\n                return this.getClient().post(this._channelURL(), {\n                  remove_members: members\n                });\n\n              case 2:\n                data = _context12.sent;\n                this.data = data.channel;\n                return _context12.abrupt(\"return\", data);\n\n              case 5:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function removeMembers(_x10) {\n        return _removeMembers.apply(this, arguments);\n      }\n\n      return removeMembers;\n    }()\n  }, {\n    key: \"demoteModerators\",\n    value: function () {\n      var _demoteModerators = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(members) {\n        var data;\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.next = 2;\n                return this.getClient().post(this._channelURL(), {\n                  demote_moderators: members\n                });\n\n              case 2:\n                data = _context13.sent;\n                this.data = data.channel;\n                return _context13.abrupt(\"return\", data);\n\n              case 5:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function demoteModerators(_x11) {\n        return _demoteModerators.apply(this, arguments);\n      }\n\n      return demoteModerators;\n    }()\n  }, {\n    key: \"sendAction\",\n    value: function sendAction(messageID, formData) {\n      this._checkInitialized();\n\n      if (!messageID) {\n        throw Error(\"Message id is missing\");\n      }\n\n      return this.getClient().post(this.getClient().baseURL + \"/messages/\".concat(messageID, \"/action\"), {\n        message_id: messageID,\n        form_data: formData,\n        id: this.id,\n        type: this.type\n      });\n    }\n    /**\n     * keystroke - First of the typing.start and typing.stop events based on the users keystrokes.\n     *  Call this on every keystroke\n     */\n\n  }, {\n    key: \"keystroke\",\n    value: function () {\n      var _keystroke = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14() {\n        var now, diff;\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                if (this.getConfig().typing_events) {\n                  _context14.next = 2;\n                  break;\n                }\n\n                return _context14.abrupt(\"return\");\n\n              case 2:\n                now = new Date();\n                diff = now - this.lastTypingEvent;\n                this.lastKeyStroke = now;\n                this.isTyping = true; // send a typing.start every 2 seconds\n\n                if (!(diff > 2000)) {\n                  _context14.next = 10;\n                  break;\n                }\n\n                this.lastTypingEvent = new Date();\n                _context14.next = 10;\n                return this.sendEvent({\n                  type: 'typing.start'\n                });\n\n              case 10:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function keystroke() {\n        return _keystroke.apply(this, arguments);\n      }\n\n      return keystroke;\n    }()\n    /**\n     * stopTyping - Sets last typing to null and sends the typing.stop event\n     */\n\n  }, {\n    key: \"stopTyping\",\n    value: function () {\n      var _stopTyping = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15() {\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                if (this.getConfig().typing_events) {\n                  _context15.next = 2;\n                  break;\n                }\n\n                return _context15.abrupt(\"return\");\n\n              case 2:\n                this.lastTypingEvent = null;\n                this.isTyping = false;\n                _context15.next = 6;\n                return this.sendEvent({\n                  type: 'typing.stop'\n                });\n\n              case 6:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function stopTyping() {\n        return _stopTyping.apply(this, arguments);\n      }\n\n      return stopTyping;\n    }()\n    /**\n     * lastMessage - return the last message, takes into account that last few messages might not be perfectly sorted\n     *\n     * @return {type} Description\n     */\n\n  }, {\n    key: \"lastMessage\",\n    value: function lastMessage() {\n      // get last 5 messages, sort, return the latest\n      // get a slice of the last 5\n      var min = this.state.messages.length - 5;\n\n      if (min < 0) {\n        min = 0;\n      }\n\n      var max = this.state.messages.length + 1;\n      var messageSlice = this.state.messages.slice(min, max).asMutable(); // sort by pk desc\n\n      messageSlice.sort(function (a, b) {\n        return b.created_at - a.created_at;\n      });\n      var lastMessage;\n\n      if (messageSlice.length > 0) {\n        lastMessage = messageSlice[0];\n      }\n\n      return lastMessage;\n    }\n    /**\n     * markRead - Send the mark read event for this user, only works if the `read_events` setting is enabled\n     *\n     * @return {Promise} Description\n     */\n\n  }, {\n    key: \"markRead\",\n    value: function () {\n      var _markRead = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16() {\n        var data,\n            response,\n            _args16 = arguments;\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                data = _args16.length > 0 && _args16[0] !== undefined ? _args16[0] : {};\n\n                this._checkInitialized();\n\n                if (this.getConfig().read_events) {\n                  _context16.next = 4;\n                  break;\n                }\n\n                return _context16.abrupt(\"return\", Promise.resolve(null));\n\n              case 4:\n                _context16.next = 6;\n                return this.getClient().post(this._channelURL() + '/read', _objectSpread({}, data));\n\n              case 6:\n                response = _context16.sent;\n                return _context16.abrupt(\"return\", response);\n\n              case 8:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function markRead() {\n        return _markRead.apply(this, arguments);\n      }\n\n      return markRead;\n    }()\n    /**\n     * clean - Cleans the channel state and fires stop typing if needed\n     */\n\n  }, {\n    key: \"clean\",\n    value: function clean() {\n      if (this.lastKeyStroke) {\n        var now = new Date();\n        var diff = now - this.lastKeyStroke;\n\n        if (diff > 1000 && this.isTyping) {\n          logChatPromiseExecution(this.stopTyping(), 'stop typing event');\n        }\n      }\n\n      this.state.clean();\n    }\n    /**\n     * watch - Loads the initial channel state and watches for changes\n     *\n     * @param {object} options additional options for the query endpoint\n     *\n     * @return {object} The server response\n     */\n\n  }, {\n    key: \"watch\",\n    value: function () {\n      var _watch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17(options) {\n        var defaultOptions, combined, state;\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                defaultOptions = {\n                  state: true,\n                  watch: true,\n                  presence: false\n                }; // Make sure we wait for the connect promise if there is a pending one\n\n                _context17.next = 3;\n                return this.getClient().wsPromise;\n\n              case 3:\n                if (!this.getClient()._hasConnectionID()) {\n                  defaultOptions.watch = false;\n                }\n\n                combined = _objectSpread({}, defaultOptions, {}, options);\n                _context17.next = 7;\n                return this.query(combined);\n\n              case 7:\n                state = _context17.sent;\n                this.initialized = true;\n\n                this._initializeState(state);\n\n                this.data = state.channel;\n\n                this._client.logger('info', \"channel:watch() - started watching channel \".concat(this.cid), {\n                  tags: ['channel'],\n                  channel: this\n                });\n\n                return _context17.abrupt(\"return\", state);\n\n              case 13:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function watch(_x12) {\n        return _watch.apply(this, arguments);\n      }\n\n      return watch;\n    }()\n    /**\n     * stopwatching - Stops watching the channel\n     *\n     * @return {object} The server response\n     */\n\n  }, {\n    key: \"stopWatching\",\n    value: function () {\n      var _stopWatching = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18() {\n        var response;\n        return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                _context18.next = 2;\n                return this.getClient().post(this._channelURL() + '/stop-watching', {});\n\n              case 2:\n                response = _context18.sent;\n\n                this._client.logger('info', \"channel:watch() - stopped watching channel \".concat(this.cid), {\n                  tags: ['channel'],\n                  channel: this\n                });\n\n                return _context18.abrupt(\"return\", response);\n\n              case 5:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n\n      function stopWatching() {\n        return _stopWatching.apply(this, arguments);\n      }\n\n      return stopWatching;\n    }()\n    /**\n     * getReplies - List the message replies for a parent message\n     *\n     * @param {type} parent_id The message parent id, ie the top of the thread\n     * @param {type} options   Pagination params, ie {limit:10, idlte: 10}\n     *\n     * @return {type} A response with a list of messages\n     */\n\n  }, {\n    key: \"getReplies\",\n    value: function () {\n      var _getReplies = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19(parent_id, options) {\n        var data;\n        return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                _context19.next = 2;\n                return this.getClient().get(this.getClient().baseURL + \"/messages/\".concat(parent_id, \"/replies\"), _objectSpread({}, options));\n\n              case 2:\n                data = _context19.sent; // add any messages to our thread state\n\n                if (data.messages) {\n                  this.state.addMessagesSorted(data.messages);\n                }\n\n                return _context19.abrupt(\"return\", data);\n\n              case 5:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n\n      function getReplies(_x13, _x14) {\n        return _getReplies.apply(this, arguments);\n      }\n\n      return getReplies;\n    }()\n    /**\n     * getReactions - List the reactions, supports pagination\n     *\n     * @param {string} message_id The message id\n     * @param {object} options    The pagination options\n     *\n     * @return {object} Server response\n     */\n\n  }, {\n    key: \"getReactions\",\n    value: function () {\n      var _getReactions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee20(message_id, options) {\n        var data;\n        return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                _context20.next = 2;\n                return this.getClient().get(this.getClient().baseURL + \"/messages/\".concat(message_id, \"/reactions\"), _objectSpread({}, options));\n\n              case 2:\n                data = _context20.sent;\n                return _context20.abrupt(\"return\", data);\n\n              case 4:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this);\n      }));\n\n      function getReactions(_x15, _x16) {\n        return _getReactions.apply(this, arguments);\n      }\n\n      return getReactions;\n    }()\n    /**\n     * lastRead - returns the last time the user marked the channel as read if the user never marked the channel as read, this will return null\n     * @return {date}\n     */\n\n  }, {\n    key: \"lastRead\",\n    value: function lastRead() {\n      this._checkInitialized();\n\n      return this.state.read[this.getClient().userID] ? this.state.read[this.getClient().userID].last_read : null;\n    }\n    /**\n     * countUnread - Count the number of messages with a date thats newer than the last read timestamp\n     *\n     * @param [date] lastRead the time that the user read a message, defaults to current user's read state\n     *\n     * @return {int} Unread count\n     */\n\n  }, {\n    key: \"countUnread\",\n    value: function countUnread(lastRead) {\n      if (lastRead == null) {\n        lastRead = this.lastRead();\n      }\n\n      var count = 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.state.messages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var m = _step.value;\n\n          if (this.getClient().userID === m.user.id) {\n            continue;\n          }\n\n          if (lastRead == null) {\n            count++;\n            continue;\n          }\n\n          if (m.created_at > lastRead) {\n            count++;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return count;\n    }\n    /**\n     * countUnread - Count the number of unread messages mentioning the current user\n     *\n     * @return {int} Unread mentions count\n     */\n\n  }, {\n    key: \"countUnreadMentions\",\n    value: function countUnreadMentions() {\n      var lastRead = this.lastRead();\n      var count = 0;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.state.messages[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var m = _step2.value;\n\n          if (this.getClient().userID === m.user.id) {\n            continue;\n          }\n\n          if (lastRead == null) {\n            count++;\n            continue;\n          }\n\n          if (m.created_at > lastRead) {\n            if (m.mentioned_users.map(function (u) {\n              return u.id;\n            }).indexOf(this.getClient().userID) !== -1) {\n              count++;\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return count;\n    }\n    /**\n     * create - Creates a new channel\n     *\n     * @return {type} The Server Reponse\n     */\n\n  }, {\n    key: \"query\",\n\n    /**\n     * query - Query the API, get messages, members or other channel fields\n     *\n     * @param {object} options The query options\n     *\n     * @return {object} Returns a query response\n     */\n    value: function () {\n      var _query = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee21(options) {\n        var queryURL, state;\n        return _regeneratorRuntime.wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                _context21.next = 2;\n                return this.getClient().wsPromise;\n\n              case 2:\n                queryURL = \"\".concat(this.getClient().baseURL, \"/channels/\").concat(this.type);\n\n                if (this.id) {\n                  queryURL += \"/\".concat(this.id);\n                }\n\n                _context21.next = 6;\n                return this.getClient().post(queryURL + '/query', _objectSpread({\n                  data: this._data,\n                  state: true\n                }, options));\n\n              case 6:\n                state = _context21.sent; // update the channel id if it was missing\n\n                if (!this.id) {\n                  this.id = state.channel.id;\n                  this.cid = state.channel.cid; // set the channel as active...\n\n                  if (!(this.cid in this.getClient().activeChannels)) {\n                    this.getClient().activeChannels[this.cid] = this;\n                  }\n                }\n\n                this.getClient()._addChannelConfig(state); // add any messages to our channel state\n\n\n                this._initializeState(state);\n\n                return _context21.abrupt(\"return\", state);\n\n              case 11:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n\n      function query(_x17) {\n        return _query.apply(this, arguments);\n      }\n\n      return query;\n    }()\n    /**\n     * banUser - Bans a user from a channel\n     *\n     * @param targetUserID\n     * @param options\n     * @returns {Promise<*>}\n     */\n\n  }, {\n    key: \"banUser\",\n    value: function () {\n      var _banUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee22(targetUserID, options) {\n        return _regeneratorRuntime.wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                this._checkInitialized();\n\n                _context22.next = 3;\n                return this.getClient().banUser(targetUserID, _objectSpread({}, options, {\n                  type: this.type,\n                  id: this.id\n                }));\n\n              case 3:\n                return _context22.abrupt(\"return\", _context22.sent);\n\n              case 4:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this);\n      }));\n\n      function banUser(_x18, _x19) {\n        return _banUser.apply(this, arguments);\n      }\n\n      return banUser;\n    }()\n    /**\n     * banUser - Removes the bans for a user on a channel\n     *\n     * @param targetUserID\n     * @returns {Promise<*>}\n     */\n\n  }, {\n    key: \"unbanUser\",\n    value: function () {\n      var _unbanUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee23(targetUserID) {\n        return _regeneratorRuntime.wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                this._checkInitialized();\n\n                _context23.next = 3;\n                return this.getClient().unbanUser(targetUserID, {\n                  type: this.type,\n                  id: this.id\n                });\n\n              case 3:\n                return _context23.abrupt(\"return\", _context23.sent);\n\n              case 4:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23, this);\n      }));\n\n      function unbanUser(_x20) {\n        return _unbanUser.apply(this, arguments);\n      }\n\n      return unbanUser;\n    }()\n    /**\n     * on - Listen to events on this channel.\n     *\n     * channel.on('message.new', event => {console.log(\"my new message\", event, channel.state.messages)})\n     * or\n     * channel.on(event => {console.log(event.type)})\n     *\n     * @param {string} callbackOrString  The event type to listen for (optional)\n     * @param {function} callbackOrNothing The callback to call\n     *\n     * @return {type} Description\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(callbackOrString, callbackOrNothing) {\n      var key = callbackOrNothing ? callbackOrString : 'all';\n      var valid = isValidEventType(key);\n\n      if (!valid) {\n        throw Error(\"Invalid event type \".concat(key));\n      }\n\n      var callback = callbackOrNothing ? callbackOrNothing : callbackOrString;\n\n      if (!(key in this.listeners)) {\n        this.listeners[key] = [];\n      }\n\n      this._client.logger('info', \"Attaching listener for \".concat(key, \" event on channel \").concat(this.cid), {\n        tags: ['event', 'channel'],\n        channel: this\n      });\n\n      this.listeners[key].push(callback);\n    }\n    /**\n     * off - Remove the event handler\n     *\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(callbackOrString, callbackOrNothing) {\n      this._checkInitialized();\n\n      var key = callbackOrNothing ? callbackOrString : 'all';\n      var valid = isValidEventType(key);\n\n      if (!valid) {\n        throw Error(\"Invalid event type \".concat(key));\n      }\n\n      var callback = callbackOrNothing ? callbackOrNothing : callbackOrString;\n\n      if (!(key in this.listeners)) {\n        this.listeners[key] = [];\n      }\n\n      this._client.logger('info', \"Removing listener for \".concat(key, \" event from channel \").concat(this.cid), {\n        tags: ['event', 'channel'],\n        channel: this\n      });\n\n      this.listeners[key] = this.listeners[key].filter(function (value) {\n        return value !== callback;\n      });\n    }\n  }, {\n    key: \"_handleChannelEvent\",\n    value: function _handleChannelEvent(event) {\n      var channel = this;\n\n      this._client.logger('info', \"channel:_handleChannelEvent - Received event of type { \".concat(event.type, \" } on \").concat(this.cid), {\n        tags: ['event', 'channel'],\n        channel: this\n      });\n\n      var s = channel.state;\n\n      switch (event.type) {\n        case 'typing.start':\n          s.typing = s.typing.set(event.user.id, Immutable(event));\n          break;\n\n        case 'typing.stop':\n          s.typing = s.typing.without(event.user.id);\n          break;\n\n        case 'message.read':\n          s.read = s.read.set(event.user.id, Immutable({\n            user: _objectSpread({}, event.user),\n            last_read: event.received_at\n          }));\n          break;\n\n        case 'user.watching.start':\n        case 'user.updated':\n          s.watchers = s.watchers.set(event.user.id, Immutable(event.user));\n          break;\n\n        case 'user.watching.stop':\n          s.watchers = s.watchers.without(event.user.id);\n          break;\n\n        case 'message.new':\n        case 'message.updated':\n        case 'message.deleted':\n          s.addMessageSorted(event.message);\n          break;\n\n        case 'member.added':\n        case 'member.updated':\n          s.members = s.members.set(event.member.user_id, Immutable(event.member));\n          break;\n\n        case 'member.removed':\n          s.members = s.members.without(event.user.id);\n          break;\n\n        case 'channel.updated':\n          channel.data = Immutable(event.channel);\n          break;\n\n        case 'reaction.new':\n          s.addReaction(event.reaction, event.message);\n          break;\n\n        case 'reaction.deleted':\n          s.removeReaction(event.reaction, event.message);\n          break;\n\n        default:\n      } // any event can send over the online count\n\n\n      if (event.watcher_count !== undefined) {\n        channel.state.watcher_count = event.watcher_count;\n      } // gather and call the listeners\n\n\n      var listeners = [];\n\n      if (channel.listeners.all) {\n        listeners.push.apply(listeners, _toConsumableArray(channel.listeners.all));\n      }\n\n      if (channel.listeners[event.type]) {\n        listeners.push.apply(listeners, _toConsumableArray(channel.listeners[event.type]));\n      } // call the event and send it to the listeners\n\n\n      for (var _i = 0, _listeners = listeners; _i < _listeners.length; _i++) {\n        var listener = _listeners[_i];\n        listener(event);\n      }\n    }\n    /**\n     * _channelURL - Returns the channel url\n     *\n     * @return {string} The channel url\n     */\n\n  }, {\n    key: \"_checkInitialized\",\n    value: function _checkInitialized() {\n      if (!this.initialized && !this.getClient()._isUsingServerAuth()) {\n        throw Error(\"Channel \".concat(this.cid, \" hasn't been initialized yet. Make sure to call .watch() and wait for it to resolve\"));\n      }\n    }\n  }, {\n    key: \"_initializeState\",\n    value: function _initializeState(state) {\n      // add the Users\n      if (state.members) {\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = state.members[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var m = _step3.value;\n            this.getClient().state.updateUserReference(m.user, this.cid);\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      }\n\n      if (state.watchers) {\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = state.watchers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var w = _step4.value;\n            this.getClient().state.updateUserReference(w.user, this.cid);\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      } // immutable list of maps\n\n\n      var messages = state.messages || [];\n\n      if (!this.state.messages) {\n        this.state.messages = Immutable([]);\n      }\n\n      this.state.addMessagesSorted(messages, true);\n      this.state.watcher_count = state.watcher_count; // convert the arrays into objects for easier syncing...\n\n      if (state.watchers) {\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = state.watchers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var watcher = _step5.value;\n            this.state.watchers = this.state.watchers.set(watcher.id, watcher);\n          }\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n              _iterator5.return();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n      }\n\n      if (state.read) {\n        if (this.getClient().userID != null) {\n          this.state.read = this.state.read.set(this.getClient().user.id, new Date(0));\n        }\n\n        var _iteratorNormalCompletion6 = true;\n        var _didIteratorError6 = false;\n        var _iteratorError6 = undefined;\n\n        try {\n          for (var _iterator6 = state.read[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n            var read = _step6.value;\n\n            var parsedRead = _extends(_objectSpread({}, read));\n\n            parsedRead.last_read = new Date(read.last_read);\n            this.state.read = this.state.read.set(read.user.id, parsedRead);\n          }\n        } catch (err) {\n          _didIteratorError6 = true;\n          _iteratorError6 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n              _iterator6.return();\n            }\n          } finally {\n            if (_didIteratorError6) {\n              throw _iteratorError6;\n            }\n          }\n        }\n      }\n\n      if (state.members) {\n        var _iteratorNormalCompletion7 = true;\n        var _didIteratorError7 = false;\n        var _iteratorError7 = undefined;\n\n        try {\n          for (var _iterator7 = state.members[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n            var _m = _step7.value;\n            this.state.members = this.state.members.set(_m.user.id, _m);\n          }\n        } catch (err) {\n          _didIteratorError7 = true;\n          _iteratorError7 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n              _iterator7.return();\n            }\n          } finally {\n            if (_didIteratorError7) {\n              throw _iteratorError7;\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_disconnect\",\n    value: function _disconnect() {\n      this._client.logger('info', \"channel:disconnect() - Disconnecting the channel \".concat(this.cid), {\n        tags: ['connection', 'channel'],\n        channel: this\n      });\n\n      this.disconnected = true;\n    }\n  }]);\n\n  return Channel;\n}();\n/**\n * ClientState - A container class for the client state.\n */\n\n\nvar ClientState = /*#__PURE__*/function () {\n  function ClientState() {\n    _classCallCheck(this, ClientState); // show the status for a certain user...\n    // ie online, offline etc\n\n\n    this.users = Immutable({}); // store which channels contain references to the specified user...\n\n    this.userChannelReferences = {};\n  }\n\n  _createClass(ClientState, [{\n    key: \"updateUsers\",\n    value: function updateUsers(users) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = users[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var user = _step.value;\n          this.updateUser(user);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"updateUser\",\n    value: function updateUser(user) {\n      if (user != null) {\n        this.users = this.users.set(user.id, Immutable(user));\n      }\n    }\n  }, {\n    key: \"updateUserReference\",\n    value: function updateUserReference(user, channelID) {\n      if (user == null) {\n        return;\n      }\n\n      this.updateUser(user);\n\n      if (!this.userChannelReferences[user.id]) {\n        this.userChannelReferences[user.id] = {};\n      }\n\n      this.userChannelReferences[user.id][channelID] = true;\n    }\n  }]);\n\n  return ClientState;\n}();\n/**\n * StableWSConnection - A WS connection that reconnects upon failure.\n * - the browser will sometimes report that you're online or offline\n * - the WS connection can break and fail (there is a 30s health check)\n * - sometimes your WS connection will seem to work while the user is in fact offline\n * - to speed up online/offline detection you can use the window.addEventListener('offline');\n *\n * There are 4 ways in which a connection can become unhealthy:\n * - websocket.onerror is called\n * - websocket.onclose is called\n * - the health check fails and no event is received for ~40 seconds\n * - the browser indicates the connection is now offline\n *\n * There are 2 assumptions we make about the server:\n * - state can be recovered by querying the channel again\n * - if the servers fails to publish a message to the client, the WS connection is destroyed\n */\n\n\nvar StableWSConnection = /*#__PURE__*/function () {\n  function StableWSConnection(_ref) {\n    var _this = this;\n\n    var wsURL = _ref.wsURL,\n        clientID = _ref.clientID,\n        userID = _ref.userID,\n        messageCallback = _ref.messageCallback,\n        recoverCallback = _ref.recoverCallback,\n        eventCallback = _ref.eventCallback,\n        logger = _ref.logger;\n\n    _classCallCheck(this, StableWSConnection);\n\n    _defineProperty(this, \"onlineStatusChanged\", function (event) {\n      if (event.type === 'offline') {\n        // mark the connection as down\n        _this.logger('info', 'connection:onlineStatusChanged() : Status changing to offline', {\n          tags: ['connection']\n        });\n\n        _this._setHealth(false);\n      } else if (event.type === 'online') {\n        // retry right now...\n        // We check this.isHealthy, not sure if it's always\n        // smart to create a new WS connection if the old one is still up and running.\n        // it's possible we didnt miss any messages, so this process is just expensive and not needed.\n        _this.logger('info', \"connection:onlineStatusChanged() : Status changing to online. isHealthy: \".concat(_this.isHealthy), {\n          tags: ['connection']\n        });\n\n        if (!_this.isHealthy) {\n          _this._reconnect(10);\n        }\n      }\n    });\n\n    _defineProperty(this, \"onopen\", function (wsID) {\n      if (_this.wsID !== wsID) return; // set healthy..\n\n      _this._setHealth(true);\n    });\n\n    _defineProperty(this, \"onmessage\", function (wsID, event) {\n      if (_this.wsID !== wsID) return; // we wait till the first message before we consider the connection open..\n      // the reason for this is that auth errors and similar errors trigger a ws.onopen and immediately\n      // after that a ws.onclose..\n\n      if (!_this.isResolved) {\n        _this.resolvePromise(event);\n      } // trigger the event..\n\n\n      _this.lastEvent = new Date();\n\n      _this.messageCallback(event);\n    });\n\n    _defineProperty(this, \"onclose\", function (wsID, event) {\n      if (_this.wsID !== wsID) return;\n\n      if (event.code === 1000) {\n        // this is a permanent error raised by stream..\n        // usually caused by invalid auth details\n        var error = new Error(\"WS connection reject with error \".concat(event.reason));\n        error.reason = event.reason;\n\n        _this.rejectPromise(error);\n      } else {\n        _this.consecutiveFailures += 1;\n        _this.totalFailures += 1;\n\n        _this._setHealth(false);\n\n        _this.rejectPromise(_this._errorFromWSEvent(event)); // reconnect if its an abnormal failure\n\n\n        _this._reconnect();\n      }\n    });\n\n    _defineProperty(this, \"onerror\", function (wsID, event) {\n      if (_this.wsID !== wsID) return;\n      _this.consecutiveFailures += 1;\n      _this.totalFailures += 1;\n\n      _this._setHealth(false);\n\n      _this.rejectPromise(_this._errorFromWSEvent(event));\n\n      _this._reconnect();\n    });\n\n    _defineProperty(this, \"_setHealth\", function (healthy) {\n      if (healthy && !_this.isHealthy) {\n        // yee we are online:\n        _this.isHealthy = true;\n\n        _this.eventCallback({\n          type: 'connection.changed',\n          online: true\n        });\n      }\n\n      if (!healthy && _this.isHealthy) {\n        // bummer we are offline\n        _this.isHealthy = false;\n        setTimeout(function () {\n          if (!_this.isHealthy) {\n            _this.eventCallback({\n              type: 'connection.changed',\n              online: false\n            });\n          }\n        }, 5000);\n      }\n    });\n\n    _defineProperty(this, \"_errorFromWSEvent\", function (event) {\n      var error = new Error(\"WS failed with code \".concat(event.code));\n      error.code = event.code;\n      error.isWSFailure = true;\n      return error;\n    });\n\n    _defineProperty(this, \"_listenForConnectionChanges\", function () {\n      if (typeof window !== 'undefined' && window != null && window.addEventListener != null) {\n        window.addEventListener('offline', _this.onlineStatusChanged);\n        window.addEventListener('online', _this.onlineStatusChanged);\n      }\n    });\n\n    _defineProperty(this, \"_removeConnectionListeners\", function () {\n      if (typeof window !== 'undefined' && window != null && window.addEventListener != null) {\n        window.removeEventListener('offline', _this.onlineStatusChanged);\n        window.removeEventListener('online', _this.onlineStatusChanged);\n      }\n    });\n\n    _defineProperty(this, \"_setupConnectionPromise\", function () {\n      var that = _this;\n      _this.isResolved = false;\n      /** a promise that is resolved once ws.open is called */\n\n      _this.connectionOpen = new Promise(function (resolve, reject) {\n        that.resolvePromise = resolve;\n        that.rejectPromise = reject;\n      }).then(function (e) {\n        var data = JSON.parse(e.data);\n\n        if (data.error != null) {\n          throw new Error(JSON.stringify(data.error));\n        }\n\n        return data;\n      });\n    });\n\n    this.wsURL = wsURL;\n    this.clientID = clientID;\n    this.userID = userID;\n    /** consecutive failures influence the duration of the timeout */\n\n    this.consecutiveFailures = 0;\n    /** keep track of the total number of failures */\n\n    this.totalFailures = 0;\n    /** We only make 1 attempt to reconnect at the same time.. */\n\n    this.isConnecting = false;\n    /** Boolean that indicates if we have a working connection to the server */\n\n    this.isHealthy = false;\n    /** Callback when the connection fails and recovers */\n\n    this.recoverCallback = recoverCallback;\n    this.messageCallback = messageCallback;\n    this.eventCallback = eventCallback;\n    this.logger = logger;\n    /** Incremented when a new WS connection is made */\n\n    this.wsID = 1;\n    /** Store the last event time for health checks */\n\n    this.lastEvent = null;\n    /** Send a health check message every 30 seconds */\n\n    this.healthCheckInterval = 30 * 1000;\n    /** Every second we verify that we didn't miss any health checks */\n\n    this.monitorInterval = 1 * 1000;\n\n    this._listenForConnectionChanges();\n  }\n  /**\n   * connect - Connect to the WS URL\n   *\n   * @return {promise} Promise that completes once the first health check message is received\n   */\n\n\n  _createClass(StableWSConnection, [{\n    key: \"connect\",\n    value: function () {\n      var _connect2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var healthCheck;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.isConnecting) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw Error(\"You've called connect twice, can only attempt 1 connection at the time\");\n\n              case 2:\n                _context.prev = 2;\n                this.isConnecting = true;\n                _context.next = 6;\n                return this._connect();\n\n              case 6:\n                healthCheck = _context.sent;\n                this.isConnecting = false;\n                this.consecutiveFailures = 0;\n\n                this._startMonitor();\n\n                this._startHealthCheck();\n\n                this.logger('info', \"connection:connect() - Established ws connection with healthcheck: \".concat(healthCheck), {\n                  tags: ['connection']\n                });\n                return _context.abrupt(\"return\", healthCheck);\n\n              case 15:\n                _context.prev = 15;\n                _context.t0 = _context[\"catch\"](2);\n                this.isConnecting = false;\n\n                if (_context.t0.isWSFailure) {\n                  _context.next = 20;\n                  break;\n                }\n\n                throw _context.t0;\n\n              case 20:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[2, 15]]);\n      }));\n\n      function connect() {\n        return _connect2.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n    /**\n     * disconnect - Disconnect the connection and doesn't recover...\n     *\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      this.logger('info', \"connection:disconnect() - Closing the websocket connection for wsID \".concat(this.wsID), {\n        tags: ['connection']\n      }); // start by removing all the listeners\n\n      if (this.healthCheckIntervalRef) {\n        clearInterval(this.healthCheckIntervalRef);\n      }\n\n      if (this.monitorIntervalRef) {\n        clearInterval(this.monitorIntervalRef);\n      }\n\n      this._removeConnectionListeners(); // reset the wsID;\n\n\n      this.wsID = 1;\n      this.isHealthy = false; // remove ws handlers...\n\n      if (this.ws && this.ws.removeAllListeners) {\n        this.ws.removeAllListeners();\n      }\n\n      var isClosedPromise; // and finally close...\n\n      if (this.ws && this.ws.close) {\n        // Assigning to local here because we will remove it from this before the\n        // promise resolves.\n        var ws = this.ws;\n        isClosedPromise = new Promise(function (resolve) {\n          ws.onclose = function () {\n            resolve();\n          };\n        });\n        ws.close(1000, 'Manually closed connection by calling client.disconnect()');\n      }\n\n      delete this.ws;\n      return isClosedPromise;\n    }\n    /**\n     * _connect - Connect to the WS endpoint\n     *\n     * @return {promise} Promise that completes once the first health check message is received\n     */\n\n  }, {\n    key: \"_connect\",\n    value: function () {\n      var _connect3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var response;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this._setupConnectionPromise();\n\n                this.ws = new isoWS(this.wsURL);\n                this.ws.onopen = this.onopen.bind(this, this.wsID);\n                this.ws.onclose = this.onclose.bind(this, this.wsID);\n                this.ws.onerror = this.onerror.bind(this, this.wsID);\n                this.ws.onmessage = this.onmessage.bind(this, this.wsID);\n                _context2.next = 8;\n                return this.connectionOpen;\n\n              case 8:\n                response = _context2.sent;\n                this.connectionID = response.connection_id;\n                return _context2.abrupt(\"return\", response);\n\n              case 11:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _connect() {\n        return _connect3.apply(this, arguments);\n      }\n\n      return _connect;\n    }()\n    /**\n     * _reconnect - Description\n     *\n     * @param {int} interval number of ms to wait before connecting\n     */\n\n  }, {\n    key: \"_reconnect\",\n    value: function () {\n      var _reconnect2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(interval) {\n        var open;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this.logger('info', 'connection:_reconnect() - Initiating the reconnect', {\n                  tags: ['connection']\n                }); // only allow 1 connection at the time\n\n                if (!(this.isConnecting || this.isHealthy)) {\n                  _context3.next = 4;\n                  break;\n                }\n\n                this.logger('info', 'connection:_reconnect() - Abort (1) since already connecting or healthy', {\n                  tags: ['connection']\n                });\n                return _context3.abrupt(\"return\");\n\n              case 4:\n                // reconnect in case of on error or on close\n                // also reconnect if the health check cycle fails\n                if (interval === undefined) {\n                  interval = this._retryInterval();\n                } // reconnect, or try again after a little while...\n\n\n                _context3.next = 7;\n                return sleep(interval);\n\n              case 7:\n                if (!(this.isConnecting || this.isHealthy)) {\n                  _context3.next = 10;\n                  break;\n                }\n\n                this.logger('info', 'connection:_reconnect() - Abort (2) since already connecting or healthy', {\n                  tags: ['connection']\n                });\n                return _context3.abrupt(\"return\");\n\n              case 10:\n                this.isConnecting = true; // cleanup the old connection\n\n                this.logger('info', 'connection:_reconnect() : Destroying current WS connection', {\n                  tags: ['connection']\n                });\n\n                this._destroyCurrentWSConnection();\n\n                _context3.prev = 13;\n                _context3.next = 16;\n                return this._connect();\n\n              case 16:\n                open = _context3.sent;\n\n                if (!this.recoverCallback) {\n                  _context3.next = 22;\n                  break;\n                }\n\n                this.logger('info', 'connection:_reconnect() : Waiting for recoverCallBack', {\n                  tags: ['connection']\n                });\n                _context3.next = 21;\n                return this.recoverCallback(open);\n\n              case 21:\n                this.logger('info', 'connection:_reconnect() : Finished recoverCallBack', {\n                  tags: ['connection']\n                });\n\n              case 22:\n                this.isConnecting = false;\n                this.consecutiveFailures = 0;\n                _context3.next = 30;\n                break;\n\n              case 26:\n                _context3.prev = 26;\n                _context3.t0 = _context3[\"catch\"](13);\n                this.isConnecting = false; // reconnect on WS failures, dont reconnect if there is a code bug\n\n                if (_context3.t0.isWSFailure) {\n                  this.logger('info', 'connection:_reconnect() : WS failure, so going to try to reconnect', {\n                    tags: ['connection']\n                  });\n\n                  this._reconnect();\n                }\n\n              case 30:\n                this.logger('info', 'connection:_reconnect() : == END ==', {\n                  tags: ['connection']\n                });\n\n              case 31:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[13, 26]]);\n      }));\n\n      function _reconnect(_x) {\n        return _reconnect2.apply(this, arguments);\n      }\n\n      return _reconnect;\n    }()\n    /**\n     * onlineStatusChanged - this function is called when the browser connects or disconnects from the internet.\n     *\n     * @param {object} event Event with type online or offline\n     *\n     */\n\n  }, {\n    key: \"_destroyCurrentWSConnection\",\n\n    /**\n     * _destroyCurrentWSConnection - Removes the current WS connnection\n     *\n     */\n    value: function _destroyCurrentWSConnection() {\n      // increment the ID, meaning we will ignore all messages from the old\n      // ws connection from now on.\n      this.wsID += 1;\n\n      try {\n        if (this.ws && this.ws.removeAllListeners) {\n          this.ws.removeAllListeners();\n        }\n\n        if (this.ws && this.ws.close) {\n          this.ws.close();\n        }\n      } catch (e) {// we dont care\n      }\n    }\n    /**\n     * _retryInterval - A retry interval which increases after consecutive failures\n     *\n     * @return {int} Duration to wait in milliseconds\n     */\n\n  }, {\n    key: \"_retryInterval\",\n    value: function _retryInterval() {\n      // try to reconnect in 0-5 seconds (random to spread out the load from failures)\n      var max = Math.min(500 + this.consecutiveFailures * 2000, 25000);\n      var min = Math.min(Math.max(250, (this.consecutiveFailures - 1) * 2000), 25000);\n      return Math.floor(Math.random() * (max - min) + min);\n    }\n    /**\n     * _setupPromise - sets up the this.connectOpen promise\n     */\n\n  }, {\n    key: \"_startHealthCheck\",\n\n    /**\n     * _startHealthCheck - Sends a message every 30s or so to see if the ws connection still works\n     *\n     */\n    value: function _startHealthCheck() {\n      var that = this; // 30 seconds is the recommended interval (messenger uses this)\n\n      this.healthCheckIntervalRef = setInterval(function () {\n        // send the healthcheck.., server replies with a health check event\n        var data = [{\n          type: 'health.check',\n          client_id: that.clientID,\n          user_id: that.userID\n        }]; // try to send on the connection\n\n        try {\n          that.ws.send(JSON.stringify(data));\n        } catch (e) {// error will already be detected elsewhere\n        }\n      }, that.healthCheckInterval);\n    }\n    /**\n     * _startMonitor - Verifies we didn't miss any events. Marks the connection as failed in case we did.\n     *\n     */\n\n  }, {\n    key: \"_startMonitor\",\n    value: function _startMonitor() {\n      var _this2 = this;\n\n      var that = this;\n      this.monitorIntervalRef = setInterval(function () {\n        var now = new Date(); // means we missed a health check\n\n        if (now - that.lastEvent > _this2.healthCheckInterval + 10 * 1000) {\n          _this2.logger('info', 'connection:_startMonitor - going to reconnect', {\n            tags: ['connection']\n          });\n\n          that._setHealth(false);\n\n          that._reconnect();\n        }\n      }, that.monitorInterval);\n    }\n  }]);\n\n  return StableWSConnection;\n}();\n\nvar jwt = null;\nvar crypto = null;\n\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$1(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$1(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n/**\n * Creates the JWT token that can be used for a UserSession\n * @method JWTUserSessionToken\n * @memberof signing\n * @private\n * @param {string} apiSecret - API Secret key\n * @param {string} userId - The user_id key in the JWT payload\n * @param {object} [extraData] - Extra that should be part of the JWT token\n * @param {object} [jwtOptions] - Options that can be past to jwt.sign\n * @return {string} JWT Token\n */\n\n\nfunction JWTUserToken(apiSecret, userId) {\n  var extraData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var jwtOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (typeof userId !== 'string') {\n    throw new TypeError('userId should be a string');\n  }\n\n  var payload = _objectSpread$1({\n    user_id: userId\n  }, extraData);\n\n  var opts = _extends({\n    algorithm: 'HS256',\n    noTimestamp: true\n  }, jwtOptions);\n\n  return jwt.sign(payload, apiSecret, opts);\n}\n\nfunction JWTServerToken(apiSecret) {\n  var jwtOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var payload = {\n    server: true\n  };\n\n  var opts = _extends({\n    algorithm: 'HS256',\n    noTimestamp: true\n  }, jwtOptions);\n\n  return jwt.sign(payload, apiSecret, opts);\n}\n\nfunction decodeBase64(s) {\n  var e = {},\n      w = String.fromCharCode,\n      L = s.length;\n  var i,\n      b = 0,\n      c,\n      x,\n      l = 0,\n      a,\n      r = '';\n  var A = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n  for (i = 0; i < 64; i++) {\n    e[A.charAt(i)] = i;\n  }\n\n  for (x = 0; x < L; x++) {\n    c = e[s.charAt(x)];\n    b = (b << 6) + c;\n    l += 6;\n\n    while (l >= 8) {\n      ((a = b >>> (l -= 8) & 0xff) || x < L - 2) && (r += w(a));\n    }\n  }\n\n  return r;\n}\n/**\n * @return {string}\n */\n\n\nfunction UserFromToken(token) {\n  var fragments = token.split('.');\n\n  if (fragments.length !== 3) {\n    return '';\n  }\n\n  var b64Payload = fragments[1];\n  var payload = decodeBase64(b64Payload);\n  var data = JSON.parse(payload);\n  return data.user_id;\n}\n\nfunction encodeBase64(s) {\n  if (typeof window !== 'undefined' && window.btoa) {\n    return window.btoa(s);\n  } else {\n    return Buffer.from(s.toString(), 'binary').toString('base64');\n  }\n}\n/**\n *\n * @param userId {string} the id of the user\n * @return {string}\n */\n\n\nfunction DevToken(userId) {\n  return ['eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9', //{\"alg\": \"HS256\", \"typ\": \"JWT\"}\n  encodeBase64(JSON.stringify({\n    user_id: userId\n  })), 'devtoken'].join('.');\n}\n/**\n *\n * @param body {string} the signed message\n * @param secret {string} the shared secret used to generate the signature (Stream API secret)\n * @param signature {string} the signature to validate\n * @return {boolean}\n */\n\n\nfunction CheckSignature(body, secret, signature) {\n  var key = Buffer.from(secret, 'ascii');\n  var hash = crypto.createHmac('sha256', key).update(body).digest('hex');\n  return hash === signature;\n}\n\nvar http = null;\nvar https = null;\nvar name = \"stream-chat\";\nvar version = \"1.0.4\";\nvar description = \"JS SDK for the Stream Chat API\";\nvar author = \"GetStream\";\nvar homepage = \"https://getstream.io/chat/\";\nvar repository = \"https://github.com/GetStream/stream-chat-js.git\";\nvar main = \"./dist/index.js\";\nvar module$1 = \"./dist/index.es.js\";\nvar types = \"./types/stream-chat/index.d.ts\";\nvar browser = {\n  \"./dist/index.es.js\": \"./dist/browser.es.js\",\n  \"./dist/index.js\": \"./dist/browser.js\"\n};\nvar jsdelivr = \"./dist/browser.full-bundle.min.js\";\nvar license = \"Other/Commercial\";\nvar keywords = [\"chat\", \"messaging\", \"conversation\", \"react\", \"stream\", \"getstream\", \"getstream.io\"];\nvar files = [\"/dist\", \"/types\", \"readme.md\"];\nvar dependencies = {\n  \"@babel/runtime\": \"^7.3.1\",\n  axios: \"^0.18.1\",\n  \"chai-arrays\": \"^2.0.0\",\n  \"cross-fetch\": \"^3.0.0\",\n  \"form-data\": \"^2.3.3\",\n  \"isomorphic-ws\": \"^4.0.1\",\n  jsonwebtoken: \"^8.3.0\",\n  \"seamless-immutable\": \"^7.1.4\",\n  \"@types/seamless-immutable\": \"^7.1.10\",\n  uuid: \"^3.3.2\",\n  ws: \"^6.1.3\"\n};\nvar devDependencies = {\n  \"@babel/cli\": \"^7.1.5\",\n  \"@babel/core\": \"^7.2.2\",\n  \"@babel/node\": \"^7.2.2\",\n  \"@babel/plugin-proposal-class-properties\": \"^7.1.0\",\n  \"@babel/plugin-transform-async-to-generator\": \"^7.2.0\",\n  \"@babel/plugin-transform-object-assign\": \"^7.2.0\",\n  \"@babel/plugin-transform-runtime\": \"^7.2.0\",\n  \"@babel/preset-env\": \"^7.1.6\",\n  \"@babel/register\": \"^7.0.0\",\n  \"babel-eslint\": \"^10.0.1\",\n  bluebird: \"^3.5.3\",\n  chai: \"^4.2.0\",\n  \"chai-as-promised\": \"^7.1.1\",\n  \"chai-like\": \"^1.1.1\",\n  \"chai-sorted\": \"^0.2.0\",\n  eslint: \"5.6.0\",\n  \"eslint-plugin-babel\": \"^5.3.0\",\n  \"eslint-plugin-markdown\": \"^1.0.0\",\n  faker: \"^4.1.0\",\n  husky: \"^1.3.1\",\n  \"lint-staged\": \"^8.1.0\",\n  longjohn: \"^0.2.12\",\n  mocha: \"^5.2.0\",\n  prettier: \"^1.15.2\",\n  rollup: \"^0.68.2\",\n  \"rollup-plugin-babel\": \"^4.0.3\",\n  \"rollup-plugin-commonjs\": \"^9.1.8\",\n  \"rollup-plugin-json\": \"^3.1.0\",\n  \"rollup-plugin-node-resolve\": \"^4.0.0\",\n  \"rollup-plugin-peer-deps-external\": \"^2.2.0\",\n  \"rollup-plugin-replace\": \"^2.1.0\",\n  \"rollup-plugin-scss\": \"^0.4.0\",\n  \"rollup-plugin-terser\": \"^4.0.4\",\n  \"rollup-plugin-url\": \"^2.0.0\",\n  sinon: \"^7.2.3\"\n};\nvar scripts = {\n  start: \"rollup -c -w\",\n  build: \"rollup -c\",\n  prettier: \"npx prettier --list-different '**/*.{js,ts,md,css,scss,json}' .eslintrc.json .prettierrc .babelrc\",\n  \"prettier-fix\": \"npx prettier --write '**/*.{js,ts,md,css,scss,json}' .eslintrc.json .prettierrc .babelrc\",\n  eslint: \"npx eslint '**/*.{js,md}' --max-warnings 0\",\n  dtslint: \"dtslint types/stream-chat\",\n  test: \"NODE_ENV=test mocha --exit --bail --timeout 15000 --require @babel/register test/*.js -- --async-stack-traces\",\n  testall: \"NODE_ENV=test mocha --exit --timeout 3000 --require @babel/register test/*.js -- --async-stack-traces\",\n  testwatch: \"NODE_ENV=test nodemon ./node_modules/.bin/mocha --timeout 15000 --require test-entry.js test/test.js\",\n  lint: \"npx prettier --list-different '**/*.{js,ts,css,scss,json}' .eslintrc.json .prettierrc .babelrc && npx eslint 'src/*.js' --max-warnings 0\",\n  \"lint-fix\": \"npx prettier --write '**/*.{js,ts,css,scss,json}' .eslintrc.json .prettierrc .babelrc && npx eslint --fix 'src/*.js' --max-warnings 0\",\n  prepare: \"rm -rf dist && yarn run build\",\n  preversion: \"yarn && yarn lint\",\n  version: \"git add yarn.lock\",\n  postversion: \"git push && git push --tags && npm publish\"\n};\nvar husky = {\n  hooks: {\n    \"pre-commit\": \"./dotgit/hooks/pre-commit-format.sh && dotgit/hooks/pre-commit-reject-binaries.py\"\n  }\n};\nvar pkg = {\n  name: name,\n  version: version,\n  description: description,\n  author: author,\n  homepage: homepage,\n  repository: repository,\n  main: main,\n  module: module$1,\n  \"jsnext:main\": \"./dist/index.es.js\",\n  types: types,\n  browser: browser,\n  \"react-native\": {\n    \"./dist/index.es.js\": \"./dist/browser.es.js\",\n    \"./dist/index.js\": \"./dist/browser.js\"\n  },\n  jsdelivr: jsdelivr,\n  license: license,\n  keywords: keywords,\n  files: files,\n  dependencies: dependencies,\n  devDependencies: devDependencies,\n  scripts: scripts,\n  husky: husky\n};\n\nfunction ownKeys$2(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$2(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$2(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction isReadableStream(obj) {\n  return _typeof(obj) === 'object' && _typeof(obj._read === 'function') && _typeof(obj._readableState === 'object');\n}\n\nfunction isFunction(value) {\n  return value && (Object.prototype.toString.call(value) === '[object Function]' || 'function' === typeof value || value instanceof Function);\n}\n\nvar StreamChat = /*#__PURE__*/function () {\n  function StreamChat(key, secretOrOptions, options) {\n    var _this = this;\n\n    _classCallCheck(this, StreamChat);\n\n    _defineProperty(this, \"_hasConnectionID\", function () {\n      return Boolean(_this.connectionID);\n    });\n\n    _defineProperty(this, \"dispatchEvent\", function (event) {\n      // client event handlers\n      _this._handleClientEvent(event); // channel event handlers\n\n\n      var cid = event.cid;\n      var channel = _this.activeChannels[cid];\n\n      if (channel) {\n        channel._handleChannelEvent(event);\n      }\n    });\n\n    _defineProperty(this, \"handleEvent\", function (messageEvent) {\n      // dispatch the event to the channel listeners\n      var jsonString = messageEvent.data;\n      var event = JSON.parse(jsonString);\n      event.received_at = new Date();\n\n      _this.dispatchEvent(event);\n    });\n\n    _defineProperty(this, \"recoverState\", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var cids, lastMessageIDs, _i, _Object$values, c, lastMessage, lastMessageId;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _this.logger('info', \"client:recoverState() - Start of recoverState with connectionID \".concat(_this.wsConnection.connectionID), {\n                tags: ['connection']\n              });\n\n              _this.connectionID = _this.wsConnection.connectionID;\n              cids = Object.keys(_this.activeChannels || {});\n              lastMessageIDs = {};\n\n              for (_i = 0, _Object$values = Object.values(_this.activeChannels); _i < _Object$values.length; _i++) {\n                c = _Object$values[_i];\n                lastMessage = c.lastMessage();\n                lastMessageId = void 0;\n\n                if (lastMessage) {\n                  lastMessageId = lastMessage.id;\n                }\n\n                lastMessageIDs[c.cid] = lastMessageId;\n              }\n\n              if (!cids.length) {\n                _context.next = 11;\n                break;\n              }\n\n              _this.logger('info', \"client:recoverState() - Start the querying of \".concat(cids.length, \" channels\"), {\n                tags: ['connection', 'client']\n              });\n\n              _context.next = 9;\n              return _this.queryChannels({\n                cid: {\n                  $in: cids\n                }\n              }, {\n                last_message_at: -1\n              }, {\n                limit: 30,\n                recovery: true,\n                last_message_ids: lastMessageIDs\n              });\n\n            case 9:\n              _this.logger('info', 'client:recoverState() - Querying channels finished', {\n                tags: ['connection', 'client']\n              });\n\n              _this.dispatchEvent({\n                type: 'connection.recovered'\n              });\n\n            case 11:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    })));\n\n    _defineProperty(this, \"_isUsingServerAuth\", function () {\n      // returns if were in server side mode or not...\n      var serverAuth = !!_this.secret;\n      return serverAuth;\n    }); // set the key\n\n\n    this.key = key;\n    this.userToken = null;\n    this.secret = null;\n    this.listeners = {};\n    this.state = new ClientState(); // set the secret\n\n    if (secretOrOptions && secretOrOptions.indexOf) {\n      this.secret = secretOrOptions;\n    } // set the options... and figure out defaults...\n\n\n    options = options || secretOrOptions;\n\n    if (!options) {\n      options = {};\n    }\n\n    this.browser = typeof options.browser !== 'undefined' ? options.browser : typeof window !== 'undefined';\n    this.node = !this.browser;\n    var defaultOptions = {\n      timeout: 3000\n    };\n\n    if (this.node) {\n      var nodeOptions = {\n        httpAgent: new http.Agent({\n          keepAlive: 3000\n        }),\n        httpsAgent: new https.Agent({\n          keepAlive: 3000\n        })\n      };\n      this.options = _objectSpread$2({}, nodeOptions, {}, defaultOptions, {}, options);\n    } else {\n      this.options = _objectSpread$2({}, defaultOptions, {}, options);\n      delete this.options.httpAgent;\n      delete this.options.httpsAgent;\n    }\n\n    this.setBaseURL('https://chat-us-east-1.stream-io-api.com');\n\n    if (typeof process !== 'undefined' && process.env.STREAM_LOCAL_TEST_RUN) {\n      this.setBaseURL('http://localhost:3030');\n    } // WS connection is initialized when setUser is called\n\n\n    this.wsConnection = null;\n    this.wsPromise = null; // keeps a reference to all the channels that are in use\n\n    this.activeChannels = {}; // mapping between channel groups and configs\n\n    this.configs = {};\n    this.anonymous = false;\n    /**\n     * logger function should accept 3 parameters:\n     * @param logLevel string\n     * @param message   string\n     * @param extraData object\n     *\n     * e.g.,\n     * const client = new StreamChat('api_key', {}, {\n     * \t\tlogger = (logLevel, message, extraData) => {\n     * \t\t\tconsole.log(message);\n     * \t\t}\n     * })\n     *\n     * extraData contains tags array attached to log message. Tags can have one/many of following values:\n     * 1. api\n     * 2. api_request\n     * 3. api_response\n     * 4. client\n     * 5. channel\n     * 6. connection\n     * 7. event\n     *\n     * It may also contains some extra data, some examples have been mentioned below:\n     * 1. {\n     * \t\ttags: ['api', 'api_request', 'client'],\n     * \t\turl: string,\n     * \t\tpayload: object,\n     * \t\tconfig: object\n     * }\n     * 2. {\n     * \t\ttags: ['api', 'api_response', 'client'],\n     * \t\turl: string,\n     * \t\tresponse: object\n     * }\n     * 3. {\n     * \t\ttags: ['api', 'api_response', 'client'],\n     * \t\turl: string,\n     * \t\terror: object\n     * }\n     * 4. {\n     * \t\ttags: ['event', 'client'],\n     * \t\tevent: object\n     * }\n     * 5. {\n     * \t\ttags: ['channel'],\n     * \t\tchannel: object\n     * }\n     */\n\n    this.logger = isFunction(options.logger) ? options.logger : function () {};\n  }\n\n  _createClass(StreamChat, [{\n    key: \"devToken\",\n    value: function devToken(userID) {\n      return DevToken(userID);\n    }\n  }, {\n    key: \"getAuthType\",\n    value: function getAuthType() {\n      return this.anonymous ? 'anonymous' : 'jwt';\n    }\n  }, {\n    key: \"setBaseURL\",\n    value: function setBaseURL(baseURL) {\n      this.baseURL = baseURL;\n      this.wsBaseURL = this.baseURL.replace('http', 'ws');\n    }\n  }, {\n    key: \"_setupConnection\",\n    value: function _setupConnection() {\n      this.UUID = uuidv4();\n      this.clientID = \"\".concat(this.userID, \"--\").concat(this.UUID);\n      this.wsPromise = this.connect();\n\n      this._startCleaning();\n\n      return this.wsPromise;\n    }\n  }, {\n    key: \"setUser\",\n\n    /**\n     * setUser - Set the current user, this triggers a connection to the API\n     *\n     * @param {object} user Data about this user. IE {name: \"john\"}\n     * @param {string} userToken   Token\n     *\n     * @return {promise} Returns a promise that resolves when the connection is setup\n     */\n    value: function setUser(user, userToken) {\n      if (this.userID) {\n        throw new Error('Use client.disconnect() before trying to connect as a different user. setUser was called twice.');\n      } // we generate the client id client side\n\n\n      this.userID = user.id;\n\n      if (!this.userID) {\n        throw new Error('The \"id\" field on the user is missing');\n      }\n\n      this.userToken = userToken;\n\n      if (userToken == null && this.secret != null) {\n        this.userToken = this.createToken(this.userID);\n      }\n\n      if (this.userToken == null) {\n        throw new Error('both userToken and api secret are not provided');\n      }\n\n      var tokenUserId = UserFromToken(this.userToken);\n\n      if (userToken != null && (tokenUserId == null || tokenUserId === '' || tokenUserId !== user.id)) {\n        throw new Error('userToken does not have a user_id or is not matching with user.id');\n      }\n\n      this._setUser(user);\n\n      this.anonymous = false;\n      return this._setupConnection();\n    }\n  }, {\n    key: \"_setUser\",\n    value: function _setUser(user) {\n      // this one is used by the frontend\n      this.user = user; // this one is actually used for requests...\n\n      this._user = _objectSpread$2({}, user);\n    }\n    /**\n     * updateAppSettings - updates application settings\n     *\n     * @param {object} options App settings.\n     * \t\tIE: {\n      \t\t\t\"apn_config\": {\n    \t\t\t\t\"auth_type\": \"token\",\n    \t\t\t\t\"auth_key\": fs.readFileSync(\n    \t\t\t\t\t'./apn-push-auth-key.p8',\n    \t\t\t\t\t'utf-8',\n    \t\t\t\t),\n    \t\t\t\t\"key_id\": \"keyid\",\n    \t\t\t\t\"team_id\": \"teamid\", //either ALL these 3\n    \t\t\t\t\"notification_template\": \"notification handlebars template\",\n    \t\t\t\t\"bundle_id\": \"com.apple.your.app\",\n    \t\t\t\t\"development\": true\n    \t\t\t},\n    \t\t\t\"firebase_config\": {\n    \t\t\t\t\"server_key\": \"server key from fcm\",\n    \t\t\t\t\"notification_template\": \"notification handlebars template\"\n    \t\t\t},\n    \t\t\t\"webhook_url\": \"https://acme.com/my/awesome/webhook/\"\n    \t\t}\n     */\n\n  }, {\n    key: \"updateAppSettings\",\n    value: function () {\n      var _updateAppSettings = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(options) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (options.apn_config && options.apn_config.p12_cert) {\n                  options.apn_config.p12_cert = Buffer.from(options.apn_config.p12_cert).toString('base64');\n                }\n\n                _context2.next = 3;\n                return this.patch(this.baseURL + '/app', options);\n\n              case 3:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function updateAppSettings(_x) {\n        return _updateAppSettings.apply(this, arguments);\n      }\n\n      return updateAppSettings;\n    }()\n    /**\n     * getAppSettings - retrieves application settings\n     */\n\n  }, {\n    key: \"getAppSettings\",\n    value: function () {\n      var _getAppSettings = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.get(this.baseURL + '/app');\n\n              case 2:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getAppSettings() {\n        return _getAppSettings.apply(this, arguments);\n      }\n\n      return getAppSettings;\n    }()\n    /**\n     * testPushSettings - Tests the push settings for a user with a random chat message and the configured push templates\n     *\n     * @param {string} userID User ID. If user has no devices, it will error\n     * @param {object} [data] Overrides for push templates/message used\n     * \t\tIE: {\n    \t\t\t  messageID: 'id-of-message',//will error if message does not exist\n    \t\t\t  apnTemplate: '{}', //if app doesn't have apn configured it will error\n    \t\t\t  firebaseTemplate: '{}', //if app doesn't have firebase configured it will error\n    \t\t}\n     */\n\n  }, {\n    key: \"testPushSettings\",\n    value: function () {\n      var _testPushSettings = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(userID) {\n        var data,\n            _args4 = arguments;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                data = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};\n                _context4.next = 3;\n                return this.post(this.baseURL + '/check_push', _objectSpread$2({\n                  user_id: userID\n                }, data.messageID ? {\n                  message_id: data.messageID\n                } : {}, {}, data.apnTemplate ? {\n                  apn_template: data.apnTemplate\n                } : {}, {}, data.firebaseTemplate ? {\n                  firebase_template: data.firebaseTemplate\n                } : {}));\n\n              case 3:\n                return _context4.abrupt(\"return\", _context4.sent);\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function testPushSettings(_x2) {\n        return _testPushSettings.apply(this, arguments);\n      }\n\n      return testPushSettings;\n    }()\n    /**\n     * disconnect - closes the WS connection\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      this.logger('info', 'client:disconnect() - Disconnecting the client', {\n        tags: ['connection', 'client']\n      }); // remove the user specific fields\n\n      delete this.user;\n      delete this._user;\n      delete this.userID;\n\n      if (this.cleaningIntervalRef != null) {\n        clearInterval(this.cleaningIntervalRef);\n        this.cleaningIntervalRef = null;\n      }\n\n      this.anonymous = false;\n      this.userToken = null;\n      this.connectionEstablishedCount = 0;\n\n      for (var _i2 = 0, _Object$values2 = Object.values(this.activeChannels); _i2 < _Object$values2.length; _i2++) {\n        var channel = _Object$values2[_i2];\n\n        channel._disconnect();\n      } // ensure we no longer return inactive channels\n\n\n      this.activeChannels = {}; // reset client state\n\n      this.state = new ClientState(); // close the WS connection\n\n      if (this.wsConnection) {\n        return this.wsConnection.disconnect();\n      }\n    }\n  }, {\n    key: \"setAnonymousUser\",\n    value: function setAnonymousUser() {\n      this.anonymous = true;\n      this.userID = uuidv4();\n\n      this._setUser({\n        id: this.userID,\n        anon: true\n      });\n\n      return this._setupConnection();\n    }\n    /**\n     * setGuestUser - Setup a temporary guest user\n     *\n     * @param {object} user Data about this user. IE {name: \"john\"}\n     *\n     * @return {promise} Returns a promise that resolves when the connection is setup\n     */\n\n  }, {\n    key: \"setGuestUser\",\n    value: function () {\n      var _setGuestUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(user) {\n        var response, _response$user, created_at, updated_at, last_active, online, guestUser;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                this.anonymous = true;\n                _context5.prev = 1;\n                _context5.next = 4;\n                return this.post(this.baseURL + '/guest', {\n                  user: user\n                });\n\n              case 4:\n                response = _context5.sent;\n                _context5.next = 11;\n                break;\n\n              case 7:\n                _context5.prev = 7;\n                _context5.t0 = _context5[\"catch\"](1);\n                this.anonymous = false;\n                throw _context5.t0;\n\n              case 11:\n                this.anonymous = false;\n                _response$user = response.user, created_at = _response$user.created_at, updated_at = _response$user.updated_at, last_active = _response$user.last_active, online = _response$user.online, guestUser = _objectWithoutProperties(_response$user, [\"created_at\", \"updated_at\", \"last_active\", \"online\"]);\n                _context5.next = 15;\n                return this.setUser(guestUser, response.access_token);\n\n              case 15:\n                return _context5.abrupt(\"return\", _context5.sent);\n\n              case 16:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[1, 7]]);\n      }));\n\n      function setGuestUser(_x3) {\n        return _setGuestUser.apply(this, arguments);\n      }\n\n      return setGuestUser;\n    }()\n    /**\n     * createToken - Creates a token to authenticate this user. This function is used server side.\n     * The resulting token should be passed to the client side when the users registers or logs in\n     *\n     * @param {string}   userID         The User ID\n     * @param {string}   exp            The expiration time for the token expressed in the number of seconds since the epoch\n     *\n     * @return {string} Returns a token\n     */\n\n  }, {\n    key: \"createToken\",\n    value: function createToken(userID, exp) {\n      var extra = {};\n\n      if (exp != null) {\n        extra.exp = exp;\n      }\n\n      return JWTUserToken(this.secret, userID, extra, {});\n    }\n    /**\n     * on - Listen to events on all channels and users your watching\n     *\n     * client.on('message.new', event => {console.log(\"my new message\", event, channel.state.messages)})\n     * or\n     * client.on(event => {console.log(event.type)})\n     *\n     * @param {string} callbackOrString  The event type to listen for (optional)\n     * @param {function} callbackOrNothing The callback to call\n     *\n     * @return {type} Description\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(callbackOrString, callbackOrNothing) {\n      var _this2 = this;\n\n      var key = callbackOrNothing ? callbackOrString : 'all';\n      var valid = isValidEventType(key);\n\n      if (!valid) {\n        throw Error(\"Invalid event type \".concat(key));\n      }\n\n      var callback = callbackOrNothing ? callbackOrNothing : callbackOrString;\n\n      if (!(key in this.listeners)) {\n        this.listeners[key] = [];\n      }\n\n      this.logger('info', \"Attaching listener for \".concat(key, \" event\"), {\n        tags: ['event', 'client']\n      });\n      this.listeners[key].push(callback);\n      return {\n        unsubscribe: function unsubscribe() {\n          _this2.listeners[key] = _this2.listeners[key].filter(function (el) {\n            return el !== callback;\n          });\n        }\n      };\n    }\n    /**\n     * off - Remove the event handler\n     *\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(callbackOrString, callbackOrNothing) {\n      var key = callbackOrNothing ? callbackOrString : 'all';\n      var valid = isValidEventType(key);\n\n      if (!valid) {\n        throw Error(\"Invalid event type \".concat(key));\n      }\n\n      var callback = callbackOrNothing ? callbackOrNothing : callbackOrString;\n\n      if (!(key in this.listeners)) {\n        this.listeners[key] = [];\n      }\n\n      this.logger('info', \"Removing listener for \".concat(key, \" event\"), {\n        tags: ['event', 'client']\n      });\n      this.listeners[key] = this.listeners[key].filter(function (value) {\n        return value !== callback;\n      });\n    }\n  }, {\n    key: \"_logApiRequest\",\n    value: function _logApiRequest(type, url, data, config) {\n      this.logger('info', \"client: \".concat(type, \" - Request - \").concat(url), {\n        tags: ['api', 'api_request', 'client'],\n        url: url,\n        payload: data,\n        config: config\n      });\n    }\n  }, {\n    key: \"_logApiResponse\",\n    value: function _logApiResponse(type, url, response) {\n      this.logger('info', \"client:\".concat(type, \" - Response - url: \").concat(url, \" > status \").concat(response.status), {\n        tags: ['api', 'api_response', 'client'],\n        url: url,\n        response: response\n      });\n    }\n  }, {\n    key: \"_logApiError\",\n    value: function _logApiError(type, url, error) {\n      this.logger('error', \"client:\".concat(type, \" - Error - url: \").concat(url), {\n        tags: ['api', 'api_response', 'client'],\n        url: url,\n        error: error\n      });\n    }\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(url, params) {\n        var response;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.prev = 0;\n\n                this._logApiRequest('get', url, {}, this._addClientParams(params));\n\n                _context6.next = 4;\n                return axios.get(url, this._addClientParams(params));\n\n              case 4:\n                response = _context6.sent;\n\n                this._logApiResponse('get', url, response);\n\n                return _context6.abrupt(\"return\", this.handleResponse(response));\n\n              case 9:\n                _context6.prev = 9;\n                _context6.t0 = _context6[\"catch\"](0);\n\n                this._logApiError('get', url, _context6.t0);\n\n                if (!_context6.t0.response) {\n                  _context6.next = 16;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", this.handleResponse(_context6.t0.response));\n\n              case 16:\n                throw _context6.t0;\n\n              case 17:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[0, 9]]);\n      }));\n\n      function get(_x4, _x5) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n  }, {\n    key: \"put\",\n    value: function () {\n      var _put = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(url, data) {\n        var response;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.prev = 0;\n\n                this._logApiRequest('put', url, data, this._addClientParams());\n\n                _context7.next = 4;\n                return axios.put(url, data, this._addClientParams());\n\n              case 4:\n                response = _context7.sent;\n\n                this._logApiResponse('put', url, response);\n\n                return _context7.abrupt(\"return\", this.handleResponse(response));\n\n              case 9:\n                _context7.prev = 9;\n                _context7.t0 = _context7[\"catch\"](0);\n\n                this._logApiError('get', url, _context7.t0);\n\n                if (!_context7.t0.response) {\n                  _context7.next = 16;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", this.handleResponse(_context7.t0.response));\n\n              case 16:\n                throw _context7.t0;\n\n              case 17:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[0, 9]]);\n      }));\n\n      function put(_x6, _x7) {\n        return _put.apply(this, arguments);\n      }\n\n      return put;\n    }()\n  }, {\n    key: \"post\",\n    value: function () {\n      var _post = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(url, data) {\n        var response;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.prev = 0;\n\n                this._logApiRequest('post', url, data, this._addClientParams());\n\n                _context8.next = 4;\n                return axios.post(url, data, this._addClientParams());\n\n              case 4:\n                response = _context8.sent;\n\n                this._logApiResponse('post', url, response);\n\n                return _context8.abrupt(\"return\", this.handleResponse(response));\n\n              case 9:\n                _context8.prev = 9;\n                _context8.t0 = _context8[\"catch\"](0);\n\n                this._logApiError('post', url, _context8.t0);\n\n                if (!_context8.t0.response) {\n                  _context8.next = 16;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", this.handleResponse(_context8.t0.response));\n\n              case 16:\n                throw _context8.t0;\n\n              case 17:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[0, 9]]);\n      }));\n\n      function post(_x8, _x9) {\n        return _post.apply(this, arguments);\n      }\n\n      return post;\n    }()\n  }, {\n    key: \"patch\",\n    value: function () {\n      var _patch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(url, data) {\n        var response;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.prev = 0;\n\n                this._logApiRequest('patch', url, data, this._addClientParams());\n\n                _context9.next = 4;\n                return axios.patch(url, data, this._addClientParams());\n\n              case 4:\n                response = _context9.sent;\n\n                this._logApiResponse('patch', url, response);\n\n                return _context9.abrupt(\"return\", this.handleResponse(response));\n\n              case 9:\n                _context9.prev = 9;\n                _context9.t0 = _context9[\"catch\"](0);\n\n                this._logApiError('patch', url, _context9.t0);\n\n                if (!_context9.t0.response) {\n                  _context9.next = 16;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", this.handleResponse(_context9.t0.response));\n\n              case 16:\n                throw _context9.t0;\n\n              case 17:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[0, 9]]);\n      }));\n\n      function patch(_x10, _x11) {\n        return _patch.apply(this, arguments);\n      }\n\n      return patch;\n    }()\n  }, {\n    key: \"delete\",\n    value: function () {\n      var _delete2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(url, params) {\n        var response;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.prev = 0;\n\n                this._logApiRequest('delete', url, {}, this._addClientParams());\n\n                _context10.next = 4;\n                return axios.delete(url, this._addClientParams(params));\n\n              case 4:\n                response = _context10.sent;\n\n                this._logApiResponse('delete', url, response);\n\n                return _context10.abrupt(\"return\", this.handleResponse(response));\n\n              case 9:\n                _context10.prev = 9;\n                _context10.t0 = _context10[\"catch\"](0);\n\n                this._logApiError('delete', url, _context10.t0);\n\n                if (!_context10.t0.response) {\n                  _context10.next = 16;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", this.handleResponse(_context10.t0.response));\n\n              case 16:\n                throw _context10.t0;\n\n              case 17:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[0, 9]]);\n      }));\n\n      function _delete(_x12, _x13) {\n        return _delete2.apply(this, arguments);\n      }\n\n      return _delete;\n    }()\n  }, {\n    key: \"sendFile\",\n    value: function () {\n      var _sendFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(url, uri, name$$1, contentType, user) {\n        var data, fileField, params, response;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                data = new FormData();\n                params = this._addClientParams();\n\n                if (isReadableStream(uri)) {\n                  fileField = uri;\n                } else {\n                  fileField = {\n                    uri: uri,\n                    name: name$$1 || uri.split('/').reverse()[0]\n                  };\n\n                  if (contentType != null) {\n                    fileField.type = contentType;\n                  }\n                }\n\n                if (user != null) {\n                  data.append('user', JSON.stringify(user));\n                }\n\n                data.append('file', fileField);\n                _context11.next = 7;\n                return fetch(\"\".concat(url, \"?api_key=\").concat(this.key), {\n                  method: 'post',\n                  body: data,\n                  headers: new Headers({\n                    Authorization: params.headers.Authorization,\n                    'stream-auth-type': this.getAuthType()\n                  })\n                });\n\n              case 7:\n                response = _context11.sent;\n                _context11.next = 10;\n                return response.json();\n\n              case 10:\n                response.data = _context11.sent;\n                return _context11.abrupt(\"return\", this.handleResponse(response));\n\n              case 12:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function sendFile(_x14, _x15, _x16, _x17, _x18) {\n        return _sendFile.apply(this, arguments);\n      }\n\n      return sendFile;\n    }()\n  }, {\n    key: \"errorFromResponse\",\n    value: function errorFromResponse(response) {\n      var err;\n      err = new Error(\"StreamChat error HTTP code: \".concat(response.status));\n\n      if (response.data && response.data.code) {\n        err = new Error(\"StreamChat error code \".concat(response.data.code, \": \").concat(response.data.message));\n        err.code = response.data.code;\n      }\n\n      err.response = response;\n      err.status = response.status;\n      return err;\n    }\n  }, {\n    key: \"handleResponse\",\n    value: function handleResponse(response) {\n      var data = response.data;\n\n      if ((response.status + '')[0] !== '2') {\n        throw this.errorFromResponse(response);\n      }\n\n      return data;\n    }\n  }, {\n    key: \"_handleClientEvent\",\n    value: function _handleClientEvent(event) {\n      var client = this;\n      this.logger('info', \"client:_handleClientEvent - Received event of type { \".concat(event.type, \" }\"), {\n        tags: ['event', 'client'],\n        event: event\n      }); // update the client.state with any changes to users\n\n      if (event.type === 'user.presence.changed' || event.type === 'user.updated') {\n        client.state.updateUser(event.user);\n\n        client._updateUserReferences(event.user);\n      }\n\n      if (event.type === 'health.check') {\n        if (event.me) {\n          client.user = event.me;\n          client.state.updateUser(event.me);\n        }\n      }\n\n      if (event.type === 'notification.message_new') {\n        this.configs[event.channel.type] = event.channel.config;\n      } // gather and call the listeners\n\n\n      var listeners = [];\n\n      if (client.listeners.all) {\n        listeners.push.apply(listeners, _toConsumableArray(client.listeners.all));\n      }\n\n      if (client.listeners[event.type]) {\n        listeners.push.apply(listeners, _toConsumableArray(client.listeners[event.type]));\n      } // call the event and send it to the listeners\n\n\n      for (var _i3 = 0, _listeners = listeners; _i3 < _listeners.length; _i3++) {\n        var listener = _listeners[_i3];\n        listener(event);\n      }\n    }\n  }, {\n    key: \"_updateUserReferences\",\n\n    /*\n    _updateUserReferences updates the members and watchers of the currently active channels\n    that contain this user\n    */\n    value: function _updateUserReferences(user) {\n      var refMap = this.state.userChannelReferences[user.id] || {};\n      var refs = Object.keys(refMap);\n\n      for (var _i4 = 0, _refs = refs; _i4 < _refs.length; _i4++) {\n        var channelID = _refs[_i4];\n        var c = this.activeChannels[channelID]; // search the members and watchers and update as needed...\n\n        if (c && c.state) {\n          if (c.state.members[user.id]) {\n            c.state.members = c.state.members.setIn([user.id, 'user'], user);\n          }\n\n          if (c.state.watchers[user.id]) {\n            c.state.watchers = c.state.watchers.setIn([user.id, 'user'], user);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"connect\",\n    value: function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n        var client, params, qs, token, authType, handshake;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                this.connecting = true;\n                client = this;\n                this.failures = 0;\n\n                if (!(client.userID == null)) {\n                  _context12.next = 5;\n                  break;\n                }\n\n                throw Error('Call setUser or setAnonymousUser before starting the connection');\n\n              case 5:\n                params = {\n                  client_id: client.client_id,\n                  user_id: client.userID,\n                  user_details: client._user,\n                  user_token: client.userToken,\n                  server_determines_connection_id: true\n                };\n                qs = encodeURIComponent(JSON.stringify(params));\n\n                if (!(qs.length > 1900)) {\n                  _context12.next = 9;\n                  break;\n                }\n\n                throw Error('User object is too large');\n\n              case 9:\n                token = this._getToken();\n                authType = this.getAuthType();\n                client.wsURL = \"\".concat(client.wsBaseURL, \"/connect?json=\").concat(qs, \"&api_key=\").concat(this.key, \"&authorization=\").concat(token, \"&stream-auth-type=\").concat(authType, \"&x-stream-client=\").concat(this._userAgent()); // The StableWSConnection handles all the reconnection logic.\n\n                this.wsConnection = new StableWSConnection({\n                  wsURL: client.wsURL,\n                  clientID: this.clientID,\n                  userID: this.userID,\n                  recoverCallback: this.recoverState,\n                  messageCallback: this.handleEvent,\n                  eventCallback: this.dispatchEvent,\n                  logger: this.logger\n                });\n                _context12.next = 15;\n                return this.wsConnection.connect();\n\n              case 15:\n                handshake = _context12.sent;\n                this.connectionID = this.wsConnection.connectionID;\n                return _context12.abrupt(\"return\", handshake);\n\n              case 18:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function connect() {\n        return _connect.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n    /**\n     * queryUsers - Query users and watch user presence\n     *\n     * @param {object} filterConditions MongoDB style filter conditions\n     * @param {object} sort             Sort options, for instance {last_active: -1}\n     * @param {object} options          Option object, {presence: true}\n     *\n     * @return {object} User Query Response\n     */\n\n  }, {\n    key: \"queryUsers\",\n    value: function () {\n      var _queryUsers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(filterConditions, sort, options) {\n        var sortFields, _i5, _Object$entries, _Object$entries$_i, k, v, defaultOptions, data;\n\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                if (!sort) {\n                  sort = {};\n                }\n\n                if (!options) {\n                  options = {};\n                }\n\n                sortFields = [];\n\n                for (_i5 = 0, _Object$entries = Object.entries(sort); _i5 < _Object$entries.length; _i5++) {\n                  _Object$entries$_i = _slicedToArray(_Object$entries[_i5], 2), k = _Object$entries$_i[0], v = _Object$entries$_i[1];\n                  sortFields.push({\n                    field: k,\n                    direction: v\n                  });\n                }\n\n                defaultOptions = {\n                  presence: true\n                }; // Make sure we wait for the connect promise if there is a pending one\n\n                _context13.next = 7;\n                return this.wsPromise;\n\n              case 7:\n                if (!this._hasConnectionID()) {\n                  defaultOptions.presence = false;\n                } // Return a list of users\n\n\n                _context13.next = 10;\n                return this.get(this.baseURL + '/users', {\n                  payload: _objectSpread$2({\n                    filter_conditions: filterConditions,\n                    sort: sortFields\n                  }, defaultOptions, {}, options)\n                });\n\n              case 10:\n                data = _context13.sent;\n                this.state.updateUsers(data.users);\n                return _context13.abrupt(\"return\", data);\n\n              case 13:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function queryUsers(_x19, _x20, _x21) {\n        return _queryUsers.apply(this, arguments);\n      }\n\n      return queryUsers;\n    }()\n  }, {\n    key: \"queryChannels\",\n    value: function () {\n      var _queryChannels = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(filterConditions) {\n        var sort,\n            options,\n            sortFields,\n            _i6,\n            _Object$entries2,\n            _Object$entries2$_i,\n            k,\n            v,\n            defaultOptions,\n            payload,\n            data,\n            channels,\n            _iteratorNormalCompletion,\n            _didIteratorError,\n            _iteratorError,\n            _iterator,\n            _step,\n            channelState,\n            _iteratorNormalCompletion2,\n            _didIteratorError2,\n            _iteratorError2,\n            _iterator2,\n            _step2,\n            _channelState,\n            c,\n            _args14 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                sort = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : {};\n                options = _args14.length > 2 && _args14[2] !== undefined ? _args14[2] : {};\n                sortFields = [];\n\n                for (_i6 = 0, _Object$entries2 = Object.entries(sort); _i6 < _Object$entries2.length; _i6++) {\n                  _Object$entries2$_i = _slicedToArray(_Object$entries2[_i6], 2), k = _Object$entries2$_i[0], v = _Object$entries2$_i[1];\n                  sortFields.push({\n                    field: k,\n                    direction: v\n                  });\n                }\n\n                defaultOptions = {\n                  state: true,\n                  watch: true,\n                  presence: false\n                }; // Make sure we wait for the connect promise if there is a pending one\n\n                _context14.next = 7;\n                return this.wsPromise;\n\n              case 7:\n                if (!this._hasConnectionID()) {\n                  defaultOptions.watch = false;\n                } // Return a list of channels\n\n\n                payload = _objectSpread$2({\n                  filter_conditions: filterConditions,\n                  sort: sortFields,\n                  user_details: this._user\n                }, defaultOptions, {}, options);\n                _context14.next = 11;\n                return this.get(this.baseURL + '/channels', {\n                  payload: payload\n                });\n\n              case 11:\n                data = _context14.sent;\n                channels = []; // update our cache of the configs\n\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _iteratorError = undefined;\n                _context14.prev = 16;\n\n                for (_iterator = data.channels[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  channelState = _step.value;\n\n                  this._addChannelConfig(channelState);\n                }\n\n                _context14.next = 24;\n                break;\n\n              case 20:\n                _context14.prev = 20;\n                _context14.t0 = _context14[\"catch\"](16);\n                _didIteratorError = true;\n                _iteratorError = _context14.t0;\n\n              case 24:\n                _context14.prev = 24;\n                _context14.prev = 25;\n\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                  _iterator.return();\n                }\n\n              case 27:\n                _context14.prev = 27;\n\n                if (!_didIteratorError) {\n                  _context14.next = 30;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 30:\n                return _context14.finish(27);\n\n              case 31:\n                return _context14.finish(24);\n\n              case 32:\n                _iteratorNormalCompletion2 = true;\n                _didIteratorError2 = false;\n                _iteratorError2 = undefined;\n                _context14.prev = 35;\n\n                for (_iterator2 = data.channels[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                  _channelState = _step2.value;\n                  c = this.channel(_channelState.channel.type, _channelState.channel.id);\n                  c.data = _channelState.channel;\n                  c.initialized = true;\n\n                  c._initializeState(_channelState);\n\n                  channels.push(c);\n                }\n\n                _context14.next = 43;\n                break;\n\n              case 39:\n                _context14.prev = 39;\n                _context14.t1 = _context14[\"catch\"](35);\n                _didIteratorError2 = true;\n                _iteratorError2 = _context14.t1;\n\n              case 43:\n                _context14.prev = 43;\n                _context14.prev = 44;\n\n                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                  _iterator2.return();\n                }\n\n              case 46:\n                _context14.prev = 46;\n\n                if (!_didIteratorError2) {\n                  _context14.next = 49;\n                  break;\n                }\n\n                throw _iteratorError2;\n\n              case 49:\n                return _context14.finish(46);\n\n              case 50:\n                return _context14.finish(43);\n\n              case 51:\n                return _context14.abrupt(\"return\", channels);\n\n              case 52:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this, [[16, 20, 24, 32], [25,, 27, 31], [35, 39, 43, 51], [44,, 46, 50]]);\n      }));\n\n      function queryChannels(_x22) {\n        return _queryChannels.apply(this, arguments);\n      }\n\n      return queryChannels;\n    }()\n  }, {\n    key: \"search\",\n    value: function () {\n      var _search = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(filterConditions, query) {\n        var options,\n            payload,\n            data,\n            _args15 = arguments;\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                options = _args15.length > 2 && _args15[2] !== undefined ? _args15[2] : {}; // Return a list of channels\n\n                payload = _objectSpread$2({\n                  filter_conditions: filterConditions,\n                  query: query\n                }, options); // Make sure we wait for the connect promise if there is a pending one\n\n                _context15.next = 4;\n                return this.wsPromise;\n\n              case 4:\n                _context15.next = 6;\n                return this.get(this.baseURL + '/search', {\n                  payload: payload\n                });\n\n              case 6:\n                data = _context15.sent;\n                return _context15.abrupt(\"return\", data);\n\n              case 8:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function search(_x23, _x24) {\n        return _search.apply(this, arguments);\n      }\n\n      return search;\n    }()\n    /**\n     * addDevice - Adds a push device for a user.\n     *\n     * @param {string} id the device id\n     * @param {string} push_provider the push provider (apn or firebase)\n     * @param {string} [userID] the user id (defaults to current user)\n     *\n     */\n\n  }, {\n    key: \"addDevice\",\n    value: function () {\n      var _addDevice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16(id, push_provider) {\n        var userID,\n            _args16 = arguments;\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                userID = _args16.length > 2 && _args16[2] !== undefined ? _args16[2] : null;\n                _context16.next = 3;\n                return this.post(this.baseURL + '/devices', _objectSpread$2({\n                  id: id,\n                  push_provider: push_provider\n                }, userID != null ? {\n                  user_id: userID\n                } : {}));\n\n              case 3:\n                return _context16.abrupt(\"return\", _context16.sent);\n\n              case 4:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function addDevice(_x25, _x26) {\n        return _addDevice.apply(this, arguments);\n      }\n\n      return addDevice;\n    }()\n    /**\n     * getDevices - Returns the devices associated with a current user\n     *\n     * @param {string} [userID] User ID. Only works on serversidex\n     *\n     * @return {devices} Array of devices\n     */\n\n  }, {\n    key: \"getDevices\",\n    value: function () {\n      var _getDevices = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17(userID) {\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                _context17.next = 2;\n                return this.get(this.baseURL + '/devices', userID ? {\n                  user_id: userID\n                } : {});\n\n              case 2:\n                return _context17.abrupt(\"return\", _context17.sent);\n\n              case 3:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function getDevices(_x27) {\n        return _getDevices.apply(this, arguments);\n      }\n\n      return getDevices;\n    }()\n    /**\n     * removeDevice - Removes the device with the given id. Clientside users can only delete their own devices\n     *\n     * @param {string} id The device id\n     * @param {string} [userID] The user id. Only specify this for serverside requests\n     *\n     */\n\n  }, {\n    key: \"removeDevice\",\n    value: function () {\n      var _removeDevice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18(id) {\n        var userID,\n            _args18 = arguments;\n        return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                userID = _args18.length > 1 && _args18[1] !== undefined ? _args18[1] : null;\n                _context18.next = 3;\n                return this.delete(this.baseURL + '/devices', _objectSpread$2({\n                  id: id\n                }, userID ? {\n                  user_id: userID\n                } : {}));\n\n              case 3:\n                return _context18.abrupt(\"return\", _context18.sent);\n\n              case 4:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n\n      function removeDevice(_x28) {\n        return _removeDevice.apply(this, arguments);\n      }\n\n      return removeDevice;\n    }()\n  }, {\n    key: \"_addChannelConfig\",\n    value: function _addChannelConfig(channelState) {\n      this.configs[channelState.channel.type] = channelState.channel.config;\n    }\n    /**\n     * channel - Returns a new channel with the given type and id\n     *\n     * @param {string} channelType The channel type\n     * @param {string} channelID   The channel data\n     * @param {object} [custom]      Custom data to attach to the channel\n     *\n     * @return {channel} The channel object, initialize it using channel.watch()\n     */\n\n  }, {\n    key: \"channel\",\n    value: function channel(channelType, channelID) {\n      var custom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (!this.userID && !this._isUsingServerAuth()) {\n        throw Error('Call setUser or setAnonymousUser before creating a channel');\n      }\n\n      if (~channelType.indexOf(':')) {\n        throw Error(\"Invalid channel group \".concat(channelType, \", cant contain the : character\"));\n      }\n\n      if (typeof channelID === 'string') {\n        channelID = channelID + '';\n\n        if (~channelID.indexOf(':')) {\n          throw Error(\"Invalid channel id \".concat(channelID, \", cant contain the : character\"));\n        }\n      } else {\n        // support the 2 param init method\n        custom = channelID || {};\n        channelID = undefined;\n      } // there are two ways of solving this,\n      // a. only allow 1 channel object per cid\n      // b. broadcast events to all channels\n      // the first option seems less likely to trip up devs\n\n\n      var channel;\n\n      if (channelID) {\n        var cid = \"\".concat(channelType, \":\").concat(channelID);\n\n        if (cid in this.activeChannels) {\n          channel = this.activeChannels[cid];\n\n          if (Object.keys(custom).length > 0) {\n            channel.data = custom;\n            channel._data = custom;\n          }\n        } else {\n          channel = new Channel(this, channelType, channelID, custom);\n          this.activeChannels[channel.cid] = channel;\n        }\n      } else {\n        channel = new Channel(this, channelType, undefined, custom);\n      }\n\n      return channel;\n    }\n    /**\n     * updateUser - Update or Create the given user object\n     *\n     * @param {object} A user object, the only required field is the user id. IE {id: \"myuser\"} is valid\n     *\n     * @return {object}\n     */\n\n  }, {\n    key: \"updateUser\",\n    value: function () {\n      var _updateUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19(userObject) {\n        return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                _context19.next = 2;\n                return this.updateUsers([userObject]);\n\n              case 2:\n                return _context19.abrupt(\"return\", _context19.sent);\n\n              case 3:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n\n      function updateUser(_x29) {\n        return _updateUser.apply(this, arguments);\n      }\n\n      return updateUser;\n    }()\n    /**\n     * updateUsers - Batch update the list of users\n     *\n     * @param {array} A list of users\n     *\n     * @return {object}\n     */\n\n  }, {\n    key: \"updateUsers\",\n    value: function () {\n      var _updateUsers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee20(users) {\n        var userMap, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, userObject;\n\n        return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                userMap = {};\n                _iteratorNormalCompletion3 = true;\n                _didIteratorError3 = false;\n                _iteratorError3 = undefined;\n                _context20.prev = 4;\n                _iterator3 = users[Symbol.iterator]();\n\n              case 6:\n                if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {\n                  _context20.next = 14;\n                  break;\n                }\n\n                userObject = _step3.value;\n\n                if (userObject.id) {\n                  _context20.next = 10;\n                  break;\n                }\n\n                throw Error('User ID is required when updating a user');\n\n              case 10:\n                userMap[userObject.id] = userObject;\n\n              case 11:\n                _iteratorNormalCompletion3 = true;\n                _context20.next = 6;\n                break;\n\n              case 14:\n                _context20.next = 20;\n                break;\n\n              case 16:\n                _context20.prev = 16;\n                _context20.t0 = _context20[\"catch\"](4);\n                _didIteratorError3 = true;\n                _iteratorError3 = _context20.t0;\n\n              case 20:\n                _context20.prev = 20;\n                _context20.prev = 21;\n\n                if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                  _iterator3.return();\n                }\n\n              case 23:\n                _context20.prev = 23;\n\n                if (!_didIteratorError3) {\n                  _context20.next = 26;\n                  break;\n                }\n\n                throw _iteratorError3;\n\n              case 26:\n                return _context20.finish(23);\n\n              case 27:\n                return _context20.finish(20);\n\n              case 28:\n                _context20.next = 30;\n                return this.post(this.baseURL + '/users', {\n                  users: userMap\n                });\n\n              case 30:\n                return _context20.abrupt(\"return\", _context20.sent);\n\n              case 31:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this, [[4, 16, 20, 28], [21,, 23, 27]]);\n      }));\n\n      function updateUsers(_x30) {\n        return _updateUsers.apply(this, arguments);\n      }\n\n      return updateUsers;\n    }()\n  }, {\n    key: \"deleteUser\",\n    value: function () {\n      var _deleteUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee21(userID, params) {\n        return _regeneratorRuntime.wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                _context21.next = 2;\n                return this.delete(this.baseURL + \"/users/\".concat(userID), params);\n\n              case 2:\n                return _context21.abrupt(\"return\", _context21.sent);\n\n              case 3:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n\n      function deleteUser(_x31, _x32) {\n        return _deleteUser.apply(this, arguments);\n      }\n\n      return deleteUser;\n    }()\n  }, {\n    key: \"reactivateUser\",\n    value: function () {\n      var _reactivateUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee22(userID, options) {\n        return _regeneratorRuntime.wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                _context22.next = 2;\n                return this.post(this.baseURL + \"/users/\".concat(userID, \"/reactivate\"), _objectSpread$2({}, options));\n\n              case 2:\n                return _context22.abrupt(\"return\", _context22.sent);\n\n              case 3:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this);\n      }));\n\n      function reactivateUser(_x33, _x34) {\n        return _reactivateUser.apply(this, arguments);\n      }\n\n      return reactivateUser;\n    }()\n  }, {\n    key: \"deactivateUser\",\n    value: function () {\n      var _deactivateUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee23(userID, options) {\n        return _regeneratorRuntime.wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                _context23.next = 2;\n                return this.post(this.baseURL + \"/users/\".concat(userID, \"/deactivate\"), _objectSpread$2({}, options));\n\n              case 2:\n                return _context23.abrupt(\"return\", _context23.sent);\n\n              case 3:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23, this);\n      }));\n\n      function deactivateUser(_x35, _x36) {\n        return _deactivateUser.apply(this, arguments);\n      }\n\n      return deactivateUser;\n    }()\n  }, {\n    key: \"exportUser\",\n    value: function () {\n      var _exportUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee24(userID, options) {\n        return _regeneratorRuntime.wrap(function _callee24$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                _context24.next = 2;\n                return this.get(this.baseURL + \"/users/\".concat(userID, \"/export\"), _objectSpread$2({}, options));\n\n              case 2:\n                return _context24.abrupt(\"return\", _context24.sent);\n\n              case 3:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee24, this);\n      }));\n\n      function exportUser(_x37, _x38) {\n        return _exportUser.apply(this, arguments);\n      }\n\n      return exportUser;\n    }()\n    /** banUser - bans a user from all channels\n     *\n     * @param targetUserID\n     * @param options\n     * @returns {Promise<*>}\n     */\n\n  }, {\n    key: \"banUser\",\n    value: function () {\n      var _banUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee25(targetUserID, options) {\n        return _regeneratorRuntime.wrap(function _callee25$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                _context25.next = 2;\n                return this.post(this.baseURL + '/moderation/ban', _objectSpread$2({\n                  target_user_id: targetUserID\n                }, options));\n\n              case 2:\n                return _context25.abrupt(\"return\", _context25.sent);\n\n              case 3:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee25, this);\n      }));\n\n      function banUser(_x39, _x40) {\n        return _banUser.apply(this, arguments);\n      }\n\n      return banUser;\n    }()\n    /** unbanUser - revoke global ban for a user\n     *\n     * @param targetUserID\n     * @returns {Promise<*>}\n     */\n\n  }, {\n    key: \"unbanUser\",\n    value: function () {\n      var _unbanUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee26(targetUserID, options) {\n        return _regeneratorRuntime.wrap(function _callee26$(_context26) {\n          while (1) {\n            switch (_context26.prev = _context26.next) {\n              case 0:\n                _context26.next = 2;\n                return this.delete(this.baseURL + '/moderation/ban', _objectSpread$2({\n                  target_user_id: targetUserID\n                }, options));\n\n              case 2:\n                return _context26.abrupt(\"return\", _context26.sent);\n\n              case 3:\n              case \"end\":\n                return _context26.stop();\n            }\n          }\n        }, _callee26, this);\n      }));\n\n      function unbanUser(_x41, _x42) {\n        return _unbanUser.apply(this, arguments);\n      }\n\n      return unbanUser;\n    }()\n    /** muteUser - mutes a user\n     *\n     * @param targetID\n     * @param [userID] Only used with serverside auth\n     * @returns {Promise<*>}\n     */\n\n  }, {\n    key: \"muteUser\",\n    value: function () {\n      var _muteUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee27(targetID) {\n        var userID,\n            _args27 = arguments;\n        return _regeneratorRuntime.wrap(function _callee27$(_context27) {\n          while (1) {\n            switch (_context27.prev = _context27.next) {\n              case 0:\n                userID = _args27.length > 1 && _args27[1] !== undefined ? _args27[1] : null;\n                _context27.next = 3;\n                return this.post(this.baseURL + '/moderation/mute', _objectSpread$2({\n                  target_id: targetID\n                }, userID ? {\n                  user_id: userID\n                } : {}));\n\n              case 3:\n                return _context27.abrupt(\"return\", _context27.sent);\n\n              case 4:\n              case \"end\":\n                return _context27.stop();\n            }\n          }\n        }, _callee27, this);\n      }));\n\n      function muteUser(_x43) {\n        return _muteUser.apply(this, arguments);\n      }\n\n      return muteUser;\n    }()\n    /** unmuteUser - unmutes a user\n     *\n     * @param targetID\n     * @param [userID] Only used with serverside auth\n     * @returns {Promise<*>}\n     */\n\n  }, {\n    key: \"unmuteUser\",\n    value: function () {\n      var _unmuteUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee28(targetID) {\n        var userID,\n            _args28 = arguments;\n        return _regeneratorRuntime.wrap(function _callee28$(_context28) {\n          while (1) {\n            switch (_context28.prev = _context28.next) {\n              case 0:\n                userID = _args28.length > 1 && _args28[1] !== undefined ? _args28[1] : null;\n                _context28.next = 3;\n                return this.post(this.baseURL + '/moderation/unmute', _objectSpread$2({\n                  target_id: targetID\n                }, userID ? {\n                  user_id: userID\n                } : {}));\n\n              case 3:\n                return _context28.abrupt(\"return\", _context28.sent);\n\n              case 4:\n              case \"end\":\n                return _context28.stop();\n            }\n          }\n        }, _callee28, this);\n      }));\n\n      function unmuteUser(_x44) {\n        return _unmuteUser.apply(this, arguments);\n      }\n\n      return unmuteUser;\n    }()\n  }, {\n    key: \"flagMessage\",\n    value: function () {\n      var _flagMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee29(messageID) {\n        return _regeneratorRuntime.wrap(function _callee29$(_context29) {\n          while (1) {\n            switch (_context29.prev = _context29.next) {\n              case 0:\n                _context29.next = 2;\n                return this.post(this.baseURL + '/moderation/flag', {\n                  target_message_id: messageID\n                });\n\n              case 2:\n                return _context29.abrupt(\"return\", _context29.sent);\n\n              case 3:\n              case \"end\":\n                return _context29.stop();\n            }\n          }\n        }, _callee29, this);\n      }));\n\n      function flagMessage(_x45) {\n        return _flagMessage.apply(this, arguments);\n      }\n\n      return flagMessage;\n    }()\n  }, {\n    key: \"flagUser\",\n    value: function () {\n      var _flagUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee30(userID) {\n        return _regeneratorRuntime.wrap(function _callee30$(_context30) {\n          while (1) {\n            switch (_context30.prev = _context30.next) {\n              case 0:\n                _context30.next = 2;\n                return this.post(this.baseURL + '/moderation/flag', {\n                  target_user_id: userID\n                });\n\n              case 2:\n                return _context30.abrupt(\"return\", _context30.sent);\n\n              case 3:\n              case \"end\":\n                return _context30.stop();\n            }\n          }\n        }, _callee30, this);\n      }));\n\n      function flagUser(_x46) {\n        return _flagUser.apply(this, arguments);\n      }\n\n      return flagUser;\n    }()\n  }, {\n    key: \"unflagMessage\",\n    value: function () {\n      var _unflagMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee31(messageID) {\n        return _regeneratorRuntime.wrap(function _callee31$(_context31) {\n          while (1) {\n            switch (_context31.prev = _context31.next) {\n              case 0:\n                _context31.next = 2;\n                return this.post(this.baseURL + '/moderation/unflag', {\n                  target_message_id: messageID\n                });\n\n              case 2:\n                return _context31.abrupt(\"return\", _context31.sent);\n\n              case 3:\n              case \"end\":\n                return _context31.stop();\n            }\n          }\n        }, _callee31, this);\n      }));\n\n      function unflagMessage(_x47) {\n        return _unflagMessage.apply(this, arguments);\n      }\n\n      return unflagMessage;\n    }()\n  }, {\n    key: \"unflagUser\",\n    value: function () {\n      var _unflagUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee32(userID) {\n        return _regeneratorRuntime.wrap(function _callee32$(_context32) {\n          while (1) {\n            switch (_context32.prev = _context32.next) {\n              case 0:\n                _context32.next = 2;\n                return this.post(this.baseURL + '/moderation/unflag', {\n                  target_user_id: userID\n                });\n\n              case 2:\n                return _context32.abrupt(\"return\", _context32.sent);\n\n              case 3:\n              case \"end\":\n                return _context32.stop();\n            }\n          }\n        }, _callee32, this);\n      }));\n\n      function unflagUser(_x48) {\n        return _unflagUser.apply(this, arguments);\n      }\n\n      return unflagUser;\n    }()\n    /**\n     * markAllRead - marks all channels for this user as read\n     *\n     * @return {Promise} Description\n     */\n\n  }, {\n    key: \"markAllRead\",\n    value: function () {\n      var _markAllRead = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee33() {\n        var data,\n            response,\n            _args33 = arguments;\n        return _regeneratorRuntime.wrap(function _callee33$(_context33) {\n          while (1) {\n            switch (_context33.prev = _context33.next) {\n              case 0:\n                data = _args33.length > 0 && _args33[0] !== undefined ? _args33[0] : {};\n                _context33.next = 3;\n                return this.post(this.baseURL + '/channels/read', _objectSpread$2({}, data));\n\n              case 3:\n                response = _context33.sent;\n\n              case 4:\n              case \"end\":\n                return _context33.stop();\n            }\n          }\n        }, _callee33, this);\n      }));\n\n      function markAllRead() {\n        return _markAllRead.apply(this, arguments);\n      }\n\n      return markAllRead;\n    }()\n  }, {\n    key: \"createChannelType\",\n    value: function createChannelType(data) {\n      var channelData = _extends({}, {\n        commands: ['all']\n      }, data);\n\n      return this.post(this.baseURL + '/channeltypes', channelData);\n    }\n  }, {\n    key: \"getChannelType\",\n    value: function getChannelType(channelType) {\n      return this.get(this.baseURL + \"/channeltypes/\".concat(channelType));\n    }\n  }, {\n    key: \"updateChannelType\",\n    value: function updateChannelType(channelType, data) {\n      return this.put(this.baseURL + \"/channeltypes/\".concat(channelType), data);\n    }\n  }, {\n    key: \"deleteChannelType\",\n    value: function deleteChannelType(channelType) {\n      return this.delete(this.baseURL + \"/channeltypes/\".concat(channelType));\n    }\n  }, {\n    key: \"listChannelTypes\",\n    value: function listChannelTypes() {\n      return this.get(this.baseURL + \"/channeltypes\");\n    }\n    /**\n     * updateMessage - Update the given message\n     *\n     * @param {object} message object, id needs to be specified\n     *\n     * @return {object} Response that includes the message\n     */\n\n  }, {\n    key: \"updateMessage\",\n    value: function () {\n      var _updateMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee34(message, userId) {\n        var clonedMessage, reservedMessageFields;\n        return _regeneratorRuntime.wrap(function _callee34$(_context34) {\n          while (1) {\n            switch (_context34.prev = _context34.next) {\n              case 0:\n                if (message.id) {\n                  _context34.next = 2;\n                  break;\n                }\n\n                throw Error('Please specify the message id when calling updateMesssage');\n\n              case 2:\n                clonedMessage = _extends({}, message);\n                delete clonedMessage.id;\n                reservedMessageFields = ['latest_reactions', 'own_reactions', 'reply_count', 'reaction_counts', 'created_at', 'updated_at', 'html', 'command', 'type', 'user'];\n                reservedMessageFields.forEach(function (item) {\n                  if (clonedMessage[item] != null) {\n                    delete clonedMessage[item];\n                  }\n                });\n\n                if (userId != null) {\n                  if (typeof userId == 'string' || userId instanceof String) {\n                    clonedMessage.user_id = userId;\n                  } else {\n                    clonedMessage.user = {\n                      id: userId.id\n                    };\n                  }\n                }\n\n                _context34.next = 9;\n                return this.post(this.baseURL + \"/messages/\".concat(message.id), {\n                  message: clonedMessage\n                });\n\n              case 9:\n                return _context34.abrupt(\"return\", _context34.sent);\n\n              case 10:\n              case \"end\":\n                return _context34.stop();\n            }\n          }\n        }, _callee34, this);\n      }));\n\n      function updateMessage(_x49, _x50) {\n        return _updateMessage.apply(this, arguments);\n      }\n\n      return updateMessage;\n    }()\n  }, {\n    key: \"deleteMessage\",\n    value: function () {\n      var _deleteMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee35(messageID, hardDelete) {\n        var params;\n        return _regeneratorRuntime.wrap(function _callee35$(_context35) {\n          while (1) {\n            switch (_context35.prev = _context35.next) {\n              case 0:\n                params = {};\n\n                if (hardDelete) {\n                  params = {\n                    hard: true\n                  };\n                }\n\n                _context35.next = 4;\n                return this.delete(this.baseURL + \"/messages/\".concat(messageID), params);\n\n              case 4:\n                return _context35.abrupt(\"return\", _context35.sent);\n\n              case 5:\n              case \"end\":\n                return _context35.stop();\n            }\n          }\n        }, _callee35, this);\n      }));\n\n      function deleteMessage(_x51, _x52) {\n        return _deleteMessage.apply(this, arguments);\n      }\n\n      return deleteMessage;\n    }()\n  }, {\n    key: \"getMessage\",\n    value: function () {\n      var _getMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee36(messageID) {\n        return _regeneratorRuntime.wrap(function _callee36$(_context36) {\n          while (1) {\n            switch (_context36.prev = _context36.next) {\n              case 0:\n                _context36.next = 2;\n                return this.get(this.baseURL + \"/messages/\".concat(messageID));\n\n              case 2:\n                return _context36.abrupt(\"return\", _context36.sent);\n\n              case 3:\n              case \"end\":\n                return _context36.stop();\n            }\n          }\n        }, _callee36, this);\n      }));\n\n      function getMessage(_x53) {\n        return _getMessage.apply(this, arguments);\n      }\n\n      return getMessage;\n    }()\n  }, {\n    key: \"_userAgent\",\n    value: function _userAgent() {\n      return \"stream-chat-javascript-client-\".concat(this.node ? 'node' : 'browser', \"-\").concat(pkg.version);\n    }\n    /**\n     * _isUsingServerAuth - Returns true if we're using server side auth\n     */\n\n  }, {\n    key: \"_addClientParams\",\n    value: function _addClientParams() {\n      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var token = this._getToken();\n\n      return _objectSpread$2({}, this.options, {\n        params: _objectSpread$2({\n          user_id: this.userID\n        }, params, {\n          api_key: this.key,\n          connection_id: this.connectionID\n        }),\n        headers: {\n          Authorization: token,\n          'stream-auth-type': this.getAuthType(),\n          'x-stream-client': this._userAgent()\n        }\n      });\n    }\n  }, {\n    key: \"_getToken\",\n    value: function _getToken() {\n      if (this.secret == null && this.userToken == null && !this.anonymous) {\n        throw new Error(\"Both secret and user tokens are not set. Either client.setUser wasn't called or client.disconnect was called\");\n      }\n\n      var token = '';\n\n      if (!this.anonymous) {\n        token = this.userToken != null ? this.userToken : JWTServerToken(this.secret);\n      }\n\n      return token;\n    }\n  }, {\n    key: \"_startCleaning\",\n    value: function _startCleaning() {\n      var that = this;\n\n      if (this.cleaningIntervalRef != null) {\n        return;\n      }\n\n      this.cleaningIntervalRef = setInterval(function () {\n        // call clean on the channel, used for calling the stop.typing event etc.\n        for (var _i7 = 0, _Object$values3 = Object.values(that.activeChannels); _i7 < _Object$values3.length; _i7++) {\n          var channel = _Object$values3[_i7];\n          channel.clean();\n        }\n      }, 500);\n    }\n  }, {\n    key: \"verifyWebhook\",\n    value: function verifyWebhook(requestBody, xSignature) {\n      return CheckSignature(requestBody, this.secret, xSignature);\n    }\n  }]);\n\n  return StreamChat;\n}();\n\nexport { StreamChat, logChatPromiseExecution };","map":null,"metadata":{},"sourceType":"module"}